[default also_show_signature_mismatch_details]

# Without language feature V_1_4_MAP_TYPE, map functions are not defined.
SELECT MAP_FROM_ARRAY([("a", 1), ("b", 2)]);
--
ERROR: Function not found: MAP_FROM_ARRAY [at 2:8]
SELECT MAP_FROM_ARRAY([("a", 1), ("b", 2)]);
       ^
==

[default language_features=V_1_4_MAP_TYPE]

SELECT MAP_FROM_ARRAY([("a", 1), ("b", 2)]);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}, {"b", 2}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_FROM_ARRAY([STRUCT(1 AS foo, 2 AS bar), STRUCT(2, 4)]);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<foo INT64, bar INT64>>) -> MAP<INT64, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<foo INT64, bar INT64>>, value=[{foo:1, bar:2}, {foo:2, bar:4}])
    +-input_scan=
      +-SingleRowScan
==

# Struct field names hold no special meaning; only field order matters.
SELECT MAP_FROM_ARRAY([STRUCT(1 AS value, "a" AS key), STRUCT(2, "b")]);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<value INT64, key STRING>>) -> MAP<INT64, STRING>)
    |     +-Literal(type=ARRAY<STRUCT<value INT64, key STRING>>, value=[{value:1, key:"a"}, {value:2, key:"b"}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<INT64, INT64>>));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<INT64, INT64>>) -> MAP<INT64, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<INT64, INT64>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_FROM_ARRAY(CAST([] AS ARRAY<STRUCT<INT64, INT64>>));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<INT64, INT64>>) -> MAP<INT64, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<INT64, INT64>>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_FROM_ARRAY({{|"a"| [("a", "b")], "extra_arg"}})
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function MAP_FROM_ARRAY. Supported signature: MAP_FROM_ARRAY(ARRAY<STRUCT<T1, T2>>) [at 1:8]
SELECT MAP_FROM_ARRAY()
       ^
--
ALTERNATION GROUP: "a"
--
ERROR: No matching signature for function MAP_FROM_ARRAY for argument types: STRING. Supported signature: MAP_FROM_ARRAY(ARRAY) [at 1:8]
SELECT MAP_FROM_ARRAY("a")
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_FROM_ARRAY
  Argument types: STRING
  Signature: MAP_FROM_ARRAY(ARRAY<T1>)
    Argument 1: expected array type but found STRING [at 1:8]
SELECT MAP_FROM_ARRAY("a")
       ^
--
ALTERNATION GROUP:  [("a", "b")], "extra_arg"
--
ERROR: No matching signature for function MAP_FROM_ARRAY. Supported signature: MAP_FROM_ARRAY(ARRAY<STRUCT<T1, T2>>) [at 1:8]
SELECT MAP_FROM_ARRAY( [("a", "b")], "extra_arg")
       ^
==

SELECT MAP_FROM_ARRAY(NULL);
--
ERROR: MAP_FROM_ARRAY result type cannot be determined from argument NULL. Consider casting the argument to ARRAY<STRUCT<T1, T2>> so that key type T1 and value type T2 can be determined from the argument [at 1:8]
SELECT MAP_FROM_ARRAY(NULL);
       ^
==

SELECT MAP_FROM_ARRAY([]);
--
ERROR: MAP_FROM_ARRAY result type cannot be determined from argument []. Consider casting the argument to ARRAY<STRUCT<T1, T2>> so that key type T1 and value type T2 can be determined from the argument [at 1:8]
SELECT MAP_FROM_ARRAY([]);
       ^
==

SELECT MAP_FROM_ARRAY([1,2,3,4]);
--
ERROR: MAP_FROM_ARRAY input argument must be an array of structs, but got type ARRAY<INT64> [at 1:8]
SELECT MAP_FROM_ARRAY([1,2,3,4]);
       ^
==

SELECT MAP_FROM_ARRAY([(true, true, "oops")]);
--
ERROR: MAP_FROM_ARRAY input array must be of type ARRAY<STRUCT<T1, T2>>, but found a struct member with 3 fields [at 1:8]
SELECT MAP_FROM_ARRAY([(true, true, "oops")]);
       ^
==

# Error for non-groupable key
SELECT MAP_FROM_ARRAY([(new zetasql_test__.EmptyMessage(), true)]);
--
ERROR: MAP_FROM_ARRAY expected a groupable key, but got a key of type `zetasql_test__.EmptyMessage`, which does not support grouping [at 1:8]
SELECT MAP_FROM_ARRAY([(new zetasql_test__.EmptyMessage(), true)]);
       ^
==

# No error for non-groupable value
SELECT MAP_FROM_ARRAY([(true, new zetasql_test__.EmptyMessage())]);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<BOOL, PROTO<zetasql_test__.EmptyMessage>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<BOOL, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<BOOL, PROTO<zetasql_test__.EmptyMessage>>)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<BOOL, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<BOOL, PROTO<zetasql_test__.EmptyMessage>>>)
    |       +-MakeStruct
    |         +-type=STRUCT<BOOL, PROTO<zetasql_test__.EmptyMessage>>
    |         +-field_list=
    |           +-Literal(type=BOOL, value=true)
    |           +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE{{|,DISALLOW_GROUP_BY_FLOAT}}]

SELECT MAP_FROM_ARRAY([(0.1, true)]);
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DOUBLE, BOOL>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DOUBLE, BOOL>>) -> MAP<DOUBLE, BOOL>)
    |     +-Literal(type=ARRAY<STRUCT<DOUBLE, BOOL>>, value=[{0.1, true}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: ,DISALLOW_GROUP_BY_FLOAT
--
ERROR: MAP_FROM_ARRAY expected a groupable key, but got a key of type DOUBLE, which does not support grouping [at 1:8]
SELECT MAP_FROM_ARRAY([(0.1, true)]);
       ^
==

[language_features=V_1_4_MAP_TYPE,V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK]
SELECT MAP_FROM_ARRAY([('a', true), (COLLATE('Z', 'und:ci'), false)]);
--
ERROR: Collation is not allowed on argument 1 ([<"und:ci",_>]) [at 1:8]
SELECT MAP_FROM_ARRAY([('a', true), (COLLATE('Z', 'und:ci'), false)]);
       ^
==

SELECT MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([("a", 1), ("b", 2)]));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<key STRING, value INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_entries_sorted(MAP<STRING, INT64>) -> ARRAY<STRUCT<key STRING, value INT64>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}, {"b", 2}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_ENTRIES_SORTED(NULL);
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED for argument types: NULL. Supported signature: MAP_ENTRIES_SORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_SORTED(NULL);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: NULL
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    The map type could not be constructed because the key and value types were not determinable [at 1:8]
SELECT MAP_ENTRIES_SORTED(NULL);
       ^
==

SELECT MAP_ENTRIES_SORTED([]);
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED for argument types: []. Supported signature: MAP_ENTRIES_SORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_SORTED([]);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: []
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    The map type could not be constructed because the key and value types were not determinable [at 1:8]
SELECT MAP_ENTRIES_SORTED([]);
       ^
==

[default language_features=V_1_4_MAP_TYPE,V_1_2_GROUP_BY_STRUCT]

SELECT MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([(STRUCT(1), true)]));
--
ERROR: MAP_ENTRIES_SORTED map key type must be orderable, but was not: STRUCT is not orderable [at 1:8]
SELECT MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([(STRUCT(1), true)]));
       ^
==

SELECT MAP_ENTRIES_UNSORTED(MAP_FROM_ARRAY([(STRUCT(1), true)]));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<key STRUCT<INT64>, value BOOL>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_entries_unsorted(MAP<STRUCT<INT64>, BOOL>) -> ARRAY<STRUCT<key STRUCT<INT64>, value BOOL>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRUCT<INT64>, BOOL>>) -> MAP<STRUCT<INT64>, BOOL>)
    |       +-Literal(type=ARRAY<STRUCT<STRUCT<INT64>, BOOL>>, value=[{{1}, true}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_ENTRIES_UNSORTED(NULL);
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED for argument types: NULL. Supported signature: MAP_ENTRIES_UNSORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_UNSORTED(NULL);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: NULL
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    The map type could not be constructed because the key and value types were not determinable [at 1:8]
SELECT MAP_ENTRIES_UNSORTED(NULL);
       ^
==

SELECT MAP_ENTRIES_UNSORTED([]);
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED for argument types: []. Supported signature: MAP_ENTRIES_UNSORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_UNSORTED([]);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: []
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    The map type could not be constructed because the key and value types were not determinable [at 1:8]
SELECT MAP_ENTRIES_UNSORTED([]);
       ^
==

SELECT MAP_ENTRIES_SORTED([('a', 'b')]);
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED for argument types: ARRAY<STRUCT<STRING, STRING>>. Supported signature: MAP_ENTRIES_SORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_SORTED([('a', 'b')]);
       ^

--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: ARRAY<STRUCT<STRING, STRING>>
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    Argument 1: expected MAP<T1, T2>, found ARRAY<STRUCT<STRING, STRING>> [at 1:8]
SELECT MAP_ENTRIES_SORTED([('a', 'b')]);
       ^
==

SELECT MAP_ENTRIES_UNSORTED([('a', 'b')]);
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED for argument types: ARRAY<STRUCT<STRING, STRING>>. Supported signature: MAP_ENTRIES_UNSORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_UNSORTED([('a', 'b')]);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: ARRAY<STRUCT<STRING, STRING>>
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    Argument 1: expected MAP<T1, T2>, found ARRAY<STRUCT<STRING, STRING>> [at 1:8]
SELECT MAP_ENTRIES_UNSORTED([('a', 'b')]);
       ^
==

SELECT MAP_ENTRIES_SORTED({{|"a"|MAP_FROM_ARRAY([("a", "b")]), "extra_arg"}})
--
ALTERNATION GROUP: <empty>
--
ERROR: Number of arguments does not match for function MAP_ENTRIES_SORTED. Supported signature: MAP_ENTRIES_SORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_SORTED()
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_SORTED with no arguments
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    Signature requires at least 1 argument, found 0 arguments [at 1:8]
SELECT MAP_ENTRIES_SORTED()
       ^
--
ALTERNATION GROUP: "a"
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED for argument types: STRING. Supported signature: MAP_ENTRIES_SORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_SORTED("a")
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: STRING
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    Argument 1: expected MAP<T1, T2>, found STRING [at 1:8]
SELECT MAP_ENTRIES_SORTED("a")
       ^
--
ALTERNATION GROUP: MAP_FROM_ARRAY([("a", "b")]), "extra_arg"
--
ERROR: Number of arguments does not match for function MAP_ENTRIES_SORTED. Supported signature: MAP_ENTRIES_SORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([("a", "b")]), "extra_arg")
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: MAP<STRING, STRING>, STRING
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    Signature accepts at most 1 argument, found 2 arguments [at 1:8]
SELECT MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([("a", "b")]), "extra_arg")
       ^
==

SELECT MAP_ENTRIES_UNSORTED({{|"a"|MAP_FROM_ARRAY([("a", "b")]), "extra_arg"}})
--
ALTERNATION GROUP: <empty>
--
ERROR: Number of arguments does not match for function MAP_ENTRIES_UNSORTED. Supported signature: MAP_ENTRIES_UNSORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_UNSORTED()
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED with no arguments
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    Signature requires at least 1 argument, found 0 arguments [at 1:8]
SELECT MAP_ENTRIES_UNSORTED()
       ^
--
ALTERNATION GROUP: "a"
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED for argument types: STRING. Supported signature: MAP_ENTRIES_UNSORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_UNSORTED("a")
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: STRING
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    Argument 1: expected MAP<T1, T2>, found STRING [at 1:8]
SELECT MAP_ENTRIES_UNSORTED("a")
       ^
--
ALTERNATION GROUP: MAP_FROM_ARRAY([("a", "b")]), "extra_arg"
--
ERROR: Number of arguments does not match for function MAP_ENTRIES_UNSORTED. Supported signature: MAP_ENTRIES_UNSORTED(MAP) [at 1:8]
SELECT MAP_ENTRIES_UNSORTED(MAP_FROM_ARRAY([("a", "b")]), "extra_arg")
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: MAP<STRING, STRING>, STRING
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    Signature accepts at most 1 argument, found 2 arguments [at 1:8]
SELECT MAP_ENTRIES_UNSORTED(MAP_FROM_ARRAY([("a", "b")]), "extra_arg")
       ^
==

SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), {{'a'|1|NULL}});
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(0) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 1
--
ERROR: No matching signature for function MAP_GET for argument types: MAP<STRING, DOUBLE>, INT64. Supported signature: MAP_GET(MAP, ANY, [ANY]) [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), 1);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, INT64
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), 1);
       ^
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(0) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), 'a', {{0.5|'b'|1|NULL}});
--
ALTERNATION GROUP: 0.5
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(1) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=0.5)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'b'
--
ERROR: No matching signature for function MAP_GET for argument types: MAP<STRING, DOUBLE>, STRING, STRING. Supported signature: MAP_GET(MAP, ANY, [ANY]) [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), 'a', 'b');
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, STRING, STRING
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {DOUBLE, STRING} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), 'a', 'b');
       ^
--
ALTERNATION GROUP: 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(1) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(1) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(NULL, {{NULL|'a'|false}});
--
ALTERNATION GROUP: NULL
--
ERROR: No matching signature for function MAP_GET for argument types: NULL, NULL. Supported signature: MAP_GET(MAP, ANY, [ANY]) [at 1:8]
SELECT MAP_GET(NULL, NULL);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_GET
  Argument types: NULL, NULL
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    The map type could not be constructed because the value type was not determinable [at 1:8]
SELECT MAP_GET(NULL, NULL);
       ^
--
ALTERNATION GROUP: 'a'
--
ERROR: No matching signature for function MAP_GET for argument types: NULL, STRING. Supported signature: MAP_GET(MAP, ANY, [ANY]) [at 1:8]
SELECT MAP_GET(NULL, 'a');
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_GET
  Argument types: NULL, STRING
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    The map type could not be constructed because the value type was not determinable [at 1:8]
SELECT MAP_GET(NULL, 'a');
       ^
--
ALTERNATION GROUP: false
--
ERROR: No matching signature for function MAP_GET for argument types: NULL, BOOL. Supported signature: MAP_GET(MAP, ANY, [ANY]) [at 1:8]
SELECT MAP_GET(NULL, false);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_GET
  Argument types: NULL, BOOL
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    The map type could not be constructed because the value type was not determinable [at 1:8]
SELECT MAP_GET(NULL, false);
       ^
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT MAP_GET(NULL, {{NULL, NULL|NULL, 'a'|'a', NULL|'a', true}});
--
ALTERNATION GROUP: NULL, NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<INT64, INT64>, INT64, optional(1) INT64) -> INT64)
    |     +-Literal(type=MAP<INT64, INT64>, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL, 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<INT64, STRING>, INT64, optional(1) STRING) -> STRING)
    |     +-Literal(type=MAP<INT64, STRING>, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'a', NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, INT64>, STRING, optional(1) INT64) -> INT64)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'a', true
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, BOOL>, STRING, optional(1) BOOL) -> BOOL)
    |     +-Literal(type=MAP<STRING, BOOL>, value=NULL)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=BOOL, value=true)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), {{'a'|NULL|1|NULL, 1|NULL, NULL|'a', 1}});
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(0) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(0) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 1
--
ERROR: No matching signature for function MAP_GET for argument types: MAP<STRING, DOUBLE>, INT64. Supported signature: MAP_GET(MAP, ANY, [ANY]) [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), 1);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, INT64
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), 1);
       ^
--
ALTERNATION GROUP: NULL, 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(1) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL, NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(1) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=DOUBLE, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'a', 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE>, STRING, optional(1) DOUBLE) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), {{DATE('2020-01-01'), 1|'a', false}});
--
ALTERNATION GROUP: DATE('2020-01-01'), 1
--
ERROR: No matching signature for function MAP_GET for argument types: MAP<STRING, DOUBLE>, DATE, INT64. Supported signature: MAP_GET(MAP, ANY, [ANY]) [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), D...
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, DATE, INT64
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {STRING, DATE} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), D...
       ^
--
ALTERNATION GROUP: 'a', false
--
ERROR: No matching signature for function MAP_GET for argument types: MAP<STRING, DOUBLE>, STRING, BOOL. Supported signature: MAP_GET(MAP, ANY, [ANY]) [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), '...
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, STRING, BOOL
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {BOOL, DOUBLE} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), '...
       ^
==

SELECT MAP_GET(MAP_FROM_ARRAY([(1.1, "foo")]), 1);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<DOUBLE, STRING>, DOUBLE, optional(0) STRING) -> STRING)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DOUBLE, STRING>>) -> MAP<DOUBLE, STRING>)
    |     | +-Literal(type=ARRAY<STRUCT<DOUBLE, STRING>>, value=[{1.1, "foo"}])
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY([(DATE("2020-01-01"), "foo")]), "2020-01-01");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<DATE, STRING>, DATE, optional(0) STRING) -> STRING)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, STRING>>) -> MAP<DATE, STRING>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, STRING>) -> ARRAY<STRUCT<DATE, STRING>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, STRING>
    |     |     +-field_list=
    |     |       +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     |       | +-Literal(type=TIMESTAMP, value=2020-01-01 08:00:00+00)
    |     |       +-Literal(type=STRING, value="foo")
    |     +-Literal(type=DATE, value=2020-01-01)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE,V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES]
SELECT MAP_GET(MAP_FROM_ARRAY([(b'a', 1)]), 'a');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<BYTES, INT64>, BYTES, optional(0) INT64) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<BYTES, INT64>>) -> MAP<BYTES, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<BYTES, INT64>>, value=[{b"a", 1}])
    |     +-Literal(type=BYTES, value=b"a")
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY([('a', new zetasql_test__.EmptyMessage())]), 'b', '');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.EmptyMessage>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>, STRING, optional(1) PROTO<zetasql_test__.EmptyMessage>) -> PROTO<zetasql_test__.EmptyMessage>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>
    |     |     +-field_list=
    |     |       +-Literal(type=STRING, value="a")
    |     |       +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=PROTO<zetasql_test__.EmptyMessage>, value={})
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE,JSON_TYPE]
SELECT MAP_GET(MAP_FROM_ARRAY([('a', JSON '1')]), NULL, NULL);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, JSON>, STRING, optional(1) JSON) -> JSON)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, JSON>>) -> MAP<STRING, JSON>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, JSON>) -> ARRAY<STRUCT<STRING, JSON>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<STRING, JSON>
    |     |     +-field_list=
    |     |       +-Literal(type=STRING, value="a")
    |     |       +-Literal(type=JSON, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=JSON, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE,JSON_TYPE]
[no_java]
SELECT MAP_GET(MAP_FROM_ARRAY([
       ('a',
           (MAP_FROM_ARRAY([('b', JSON '1')]), new zetasql_test__.EmptyMessage())
       )]), NULL, NULL);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>, STRING, optional(1) STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>) -> STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>>) -> MAP<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>) -> ARRAY<STRUCT<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>
    |     |     +-field_list=
    |     |       +-Literal(type=STRING, value="a")
    |     |       +-MakeStruct
    |     |         +-type=STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>
    |     |         +-field_list=
    |     |           +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, JSON>>) -> MAP<STRING, JSON>)
    |     |           | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, JSON>) -> ARRAY<STRUCT<STRING, JSON>>)
    |     |           |   +-MakeStruct
    |     |           |     +-type=STRUCT<STRING, JSON>
    |     |           |     +-field_list=
    |     |           |       +-Literal(type=STRING, value="b")
    |     |           |       +-Literal(type=JSON, value=1, has_explicit_type=TRUE)
    |     |           +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_FROM_ARRAY([('a', 1)])[{{'a'|NULL|5}}];
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 5
--
ERROR: Subscript access using [INT64] is not supported on values of type MAP<STRING, INT64> [at 1:35]
SELECT MAP_FROM_ARRAY([('a', 1)])[5];
                                  ^
==

SELECT MAP_FROM_ARRAY([('a', 1)])[KEY({{'a'|NULL|5}})];
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript_with_key(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript_with_key(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 5
--
ERROR: Subscript access using [KEY(INT64)] is not supported on values of type MAP<STRING, INT64> [at 1:35]
SELECT MAP_FROM_ARRAY([('a', 1)])[KEY(5)];
                                  ^
==

[language_features=V_1_4_MAP_TYPE,V_1_2_SAFE_FUNCTION_CALL]
SELECT MAP_FROM_ARRAY([('a', 1)])[SAFE_KEY({{'a'|NULL|5}})];
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall({SAFE_ERROR_MODE} ZetaSQL:$subscript_with_key(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall({SAFE_ERROR_MODE} ZetaSQL:$subscript_with_key(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 5
--
ERROR: Subscript access using [KEY(INT64)] is not supported on values of type MAP<STRING, INT64> [at 1:35]
SELECT MAP_FROM_ARRAY([('a', 1)])[SAFE_KEY(5)];
                                  ^
==

SELECT MAP_FROM_ARRAY([(1.5, 1)])[1];
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript(MAP<DOUBLE, INT64>, DOUBLE) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DOUBLE, INT64>>) -> MAP<DOUBLE, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<DOUBLE, INT64>>, value=[{1.5, 1}])
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE{{|,V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
SELECT MAP_FROM_ARRAY([(b'hello', 1)])['bonjour'];
--
ALTERNATION GROUP: <empty>
--
ERROR: Subscript access using [STRING] is not supported on values of type MAP<BYTES, INT64> [at 1:40]
SELECT MAP_FROM_ARRAY([(b'hello', 1)])['bonjour'];
                                       ^
--
ALTERNATION GROUP: ,V_1_4_IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript(MAP<BYTES, INT64>, BYTES) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<BYTES, INT64>>) -> MAP<BYTES, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<BYTES, INT64>>, value=[{b"hello", 1}])
    |     +-Literal(type=BYTES, value=b"bonjour")
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE,V_1_2_SAFE_FUNCTION_CALL]
SELECT MAP_FROM_ARRAY([(1, 'a')])[{{OFFSET(0)|SAFE_OFFSET(0)|ORDINAL(1)|SAFE_ORDINAL(1)}}];
--
ALTERNATION GROUP: OFFSET(0)
--
ERROR: Subscript access using [OFFSET(INT64)] is not supported on values of type MAP<INT64, STRING> [at 1:35]
SELECT MAP_FROM_ARRAY([(1, 'a')])[OFFSET(0)];
                                  ^
--
ALTERNATION GROUP: SAFE_OFFSET(0)
--
ERROR: Subscript access using [OFFSET(INT64)] is not supported on values of type MAP<INT64, STRING> [at 1:35]
SELECT MAP_FROM_ARRAY([(1, 'a')])[SAFE_OFFSET(0)];
                                  ^
--
ALTERNATION GROUP: ORDINAL(1)
--
ERROR: Subscript access using [ORDINAL(INT64)] is not supported on values of type MAP<INT64, STRING> [at 1:35]
SELECT MAP_FROM_ARRAY([(1, 'a')])[ORDINAL(1)];
                                  ^
--
ALTERNATION GROUP: SAFE_ORDINAL(1)
--
ERROR: Subscript access using [ORDINAL(INT64)] is not supported on values of type MAP<INT64, STRING> [at 1:35]
SELECT MAP_FROM_ARRAY([(1, 'a')])[SAFE_ORDINAL(1)];
                                  ^
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT CAST(NULL AS MAP<STRING, STRING>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, STRING>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT
  CAST(MAP_FROM_ARRAY([("a", 1)]) AS MAP<STRING, INT64>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    +-input_scan=
      +-SingleRowScan
==

# This is supported in the spec and will be implemented in a followup.
SELECT
  CAST(MAP_FROM_ARRAY([("a", 1)]) AS MAP<STRING, FLOAT>);
--
ERROR: Invalid cast from MAP<STRING, INT64> to MAP<STRING, FLOAT> [at 2:8]
  CAST(MAP_FROM_ARRAY([("a", 1)]) AS MAP<STRING, FLOAT>);
       ^
==

# This is supported in the spec and will be implemented in a followup.
SELECT
  CAST(MAP_FROM_ARRAY([(1, "a")]) AS MAP<FLOAT, STRING>);
--
ERROR: Invalid cast from MAP<INT64, STRING> to MAP<FLOAT, STRING> [at 2:8]
  CAST(MAP_FROM_ARRAY([(1, "a")]) AS MAP<FLOAT, STRING>);
       ^
==

[no_java]
SELECT CAST(NULL AS MAP<STRING, MAP<STRING, STRING>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, MAP<STRING, STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, MAP<STRING, STRING>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[no_java]
SELECT CAST(NULL AS MAP<STRING, MAP<STRING, STRING> >);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, MAP<STRING, STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, MAP<STRING, STRING>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
# Nested types work without space if just one MAP is present.
SELECT CAST(NULL AS MAP<STRING, ARRAY<STRUCT<STRING>>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, ARRAY<STRUCT<STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, ARRAY<STRUCT<STRING>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT CAST(NULL AS ARRAY<MAP<STRING, STRUCT<STRING>>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<MAP<STRING, STRUCT<STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<MAP<STRING, STRUCT<STRING>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT CAST(NULL AS ARRAY<STRUCT<MAP<STRING, STRING>>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<MAP<STRING, STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<STRUCT<MAP<STRING, STRING>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT CAST(NULL AS MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[no_java]
SELECT CAST(NULL AS MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>> >);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT CAST(NULL AS MAP<{{zetasql_test__.EmptyMessage, STRING|STRING, zetasql_test__.EmptyMessage}}>);
--
ALTERNATION GROUP: zetasql_test__.EmptyMessage, STRING
--
ERROR: MAP key type PROTO is not groupable [at 2:21]
SELECT CAST(NULL AS MAP<zetasql_test__.EmptyMessage, STRING>);
                    ^
--
ALTERNATION GROUP: STRING, zetasql_test__.EmptyMessage
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[default language_features=V_1_4_MAP_TYPE{{,V_1_2_GROUP_BY_ARRAY,V_1_2_GROUP_BY_STRUCT|,V_1_2_GROUP_BY_ARRAY|}}]
[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT CAST(NULL AS MAP<ARRAY<STRUCT<STRING>>, STRING>);
--
ALTERNATION GROUP: ,V_1_2_GROUP_BY_ARRAY,V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<ARRAY<STRUCT<STRING>>, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<ARRAY<STRUCT<STRING>>, STRING>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: ,V_1_2_GROUP_BY_ARRAY
--
ERROR: MAP key type ARRAY containing STRUCT is not groupable [at 2:21]
SELECT CAST(NULL AS MAP<ARRAY<STRUCT<STRING>>, STRING>);
                    ^
--
ALTERNATION GROUP: <empty>
--
ERROR: MAP key type ARRAY is not groupable [at 2:21]
SELECT CAST(NULL AS MAP<ARRAY<STRUCT<STRING>>, STRING>);
                    ^
==

SELECT MAP_{{KEYS_SORTED|KEYS_UNSORTED|VALUES_SORTED|VALUES_UNSORTED}}(
  MAP_FROM_ARRAY([("k", "v")]));
--
ALTERNATION GROUP: KEYS_SORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_sorted(MAP<STRING, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRING>>) -> MAP<STRING, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=[{"k", "v"}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: KEYS_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_unsorted(MAP<STRING, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRING>>) -> MAP<STRING, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=[{"k", "v"}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_SORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_sorted(MAP<STRING, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRING>>) -> MAP<STRING, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=[{"k", "v"}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_unsorted(MAP<STRING, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRING>>) -> MAP<STRING, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=[{"k", "v"}])
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE,V_1_2_GROUP_BY_STRUCT]
# MAP key is not orderable here
SELECT MAP_{{KEYS_SORTED|KEYS_UNSORTED|VALUES_SORTED|VALUES_UNSORTED}}(
  MAP_FROM_ARRAY([(STRUCT("a"), "")]));
--
ALTERNATION GROUP: KEYS_SORTED
--
ERROR: MAP_KEYS_SORTED: MAP element type STRUCT is not orderable [at 2:8]
SELECT MAP_KEYS_SORTED(
       ^
--
ALTERNATION GROUP: KEYS_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_unsorted(MAP<STRUCT<STRING>, STRING> input_map) -> ARRAY<STRUCT<STRING>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRUCT<STRING>, STRING>>) -> MAP<STRUCT<STRING>, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRUCT<STRING>, STRING>>, value=[{{"a"}, ""}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_SORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_sorted(MAP<STRUCT<STRING>, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRUCT<STRING>, STRING>>) -> MAP<STRUCT<STRING>, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRUCT<STRING>, STRING>>, value=[{{"a"}, ""}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_unsorted(MAP<STRUCT<STRING>, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRUCT<STRING>, STRING>>) -> MAP<STRUCT<STRING>, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRUCT<STRING>, STRING>>, value=[{{"a"}, ""}])
    +-input_scan=
      +-SingleRowScan
==


# MAP value is not orderable here
SELECT MAP_{{KEYS_SORTED|KEYS_UNSORTED|VALUES_SORTED|VALUES_UNSORTED}}(
  MAP_FROM_ARRAY([("", NEW zetasql_test__.EmptyMessage())]));
--
ALTERNATION GROUP: KEYS_SORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_sorted(MAP<STRING, PROTO<zetasql_test__.EmptyMessage>> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>)
    |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>)
    |         +-MakeStruct
    |           +-type=STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>
    |           +-field_list=
    |             +-Literal(type=STRING, value="")
    |             +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: KEYS_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_unsorted(MAP<STRING, PROTO<zetasql_test__.EmptyMessage>> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>)
    |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>)
    |         +-MakeStruct
    |           +-type=STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>
    |           +-field_list=
    |             +-Literal(type=STRING, value="")
    |             +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_SORTED
--
ERROR: MAP_VALUES_SORTED: MAP element type PROTO is not orderable [at 1:8]
SELECT MAP_VALUES_SORTED(
       ^
--
ALTERNATION GROUP: VALUES_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<PROTO<zetasql_test__.EmptyMessage>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_unsorted(MAP<STRING, PROTO<zetasql_test__.EmptyMessage>> input_map) -> ARRAY<PROTO<zetasql_test__.EmptyMessage>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>)
    |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>)
    |         +-MakeStruct
    |           +-type=STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>
    |           +-field_list=
    |             +-Literal(type=STRING, value="")
    |             +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE,V_1_3_ARRAY_ORDERING]
# Array of array is not supported
SELECT MAP_{{VALUES_SORTED|VALUES_UNSORTED}}(
  MAP_FROM_ARRAY([('key', [1, 2, 3])]));
--
ALTERNATION GROUP: VALUES_SORTED
--
ERROR: No matching signature for function MAP_VALUES_SORTED for argument types: MAP<STRING, ARRAY<INT64>>. Supported signature: MAP_VALUES_SORTED(MAP) [at 2:8]
SELECT MAP_VALUES_SORTED(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_VALUES_SORTED
  Argument types: MAP<STRING, ARRAY<INT64>>
  Signature: MAP_VALUES_SORTED(MAP<T1, T2>)
    <array<T2>> is inferred to be array of array, which is not supported [at 2:8]
SELECT MAP_VALUES_SORTED(
       ^
--
ALTERNATION GROUP: VALUES_UNSORTED
--
ERROR: No matching signature for function MAP_VALUES_UNSORTED for argument types: MAP<STRING, ARRAY<INT64>>. Supported signature: MAP_VALUES_UNSORTED(MAP) [at 2:8]
SELECT MAP_VALUES_UNSORTED(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_VALUES_UNSORTED
  Argument types: MAP<STRING, ARRAY<INT64>>
  Signature: MAP_VALUES_UNSORTED(MAP<T1, T2>)
    <array<T2>> is inferred to be array of array, which is not supported [at 2:8]
SELECT MAP_VALUES_UNSORTED(
       ^
==

[language_features=V_1_4_MAP_TYPE,V_1_2_GROUP_BY_ARRAY,V_1_3_ARRAY_ORDERING]
# Array of array is not supported
SELECT MAP_{{KEYS_SORTED|KEYS_UNSORTED}}(MAP_FROM_ARRAY([([1, 2, 3], 'value')]));
--
ALTERNATION GROUP: KEYS_SORTED
--
ERROR: No matching signature for function MAP_KEYS_SORTED for argument types: MAP<ARRAY<INT64>, STRING>. Supported signature: MAP_KEYS_SORTED(MAP) [at 2:8]
SELECT MAP_KEYS_SORTED(MAP_FROM_ARRAY([([1, 2, 3], 'value')]));
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_KEYS_SORTED
  Argument types: MAP<ARRAY<INT64>, STRING>
  Signature: MAP_KEYS_SORTED(MAP<T1, T2>)
    <array<T1>> is inferred to be array of array, which is not supported [at 2:8]
SELECT MAP_KEYS_SORTED(MAP_FROM_ARRAY([([1, 2, 3], 'value')]));
       ^
--
ALTERNATION GROUP: KEYS_UNSORTED
--
ERROR: No matching signature for function MAP_KEYS_UNSORTED for argument types: MAP<ARRAY<INT64>, STRING>. Supported signature: MAP_KEYS_UNSORTED(MAP) [at 2:8]
SELECT MAP_KEYS_UNSORTED(MAP_FROM_ARRAY([([1, 2, 3], 'value')]));
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_KEYS_UNSORTED
  Argument types: MAP<ARRAY<INT64>, STRING>
  Signature: MAP_KEYS_UNSORTED(MAP<T1, T2>)
    <array<T1>> is inferred to be array of array, which is not supported [at 2:8]
SELECT MAP_KEYS_UNSORTED(MAP_FROM_ARRAY([([1, 2, 3], 'value')]));
       ^
==

SELECT MAP_VALUES_SORTED_BY_KEY(MAP_FROM_ARRAY([('b', 1), ('a', 2)]));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_sorted_by_key(MAP<STRING, INT64> input_map) -> ARRAY<INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"b", 1}, {"a", 2}])
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_4_MAP_TYPE,V_1_2_GROUP_BY_STRUCT]
SELECT MAP_VALUES_SORTED_BY_KEY(
  MAP_FROM_ARRAY([({{STRUCT('a'), 1|'a', STRUCT(1)}})]));
--
ALTERNATION GROUP: STRUCT('a'), 1
--
ERROR: MAP_VALUES_SORTED_BY_KEY: MAP element type STRUCT is not orderable [at 1:8]
SELECT MAP_VALUES_SORTED_BY_KEY(
       ^
--
ALTERNATION GROUP: 'a', STRUCT(1)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_sorted_by_key(MAP<STRING, STRUCT<INT64>> input_map) -> ARRAY<STRUCT<INT64>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRUCT<INT64>>>) -> MAP<STRING, STRUCT<INT64>>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRUCT<INT64>>>, value=[{"a", {1}}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_EMPTY(
  MAP_FROM_ARRAY({{[('a', 1)]|CAST([] AS ARRAY<STRUCT<STRING, INT64>>)|CAST(NULL AS ARRAY<STRUCT<STRING, INT64>>)}}));
--
ALTERNATION GROUP: [('a', 1)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_empty(MAP<STRING, INT64> input_map) -> BOOL)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: CAST([] AS ARRAY<STRUCT<STRING, INT64>>)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_empty(MAP<STRING, INT64> input_map) -> BOOL)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: CAST(NULL AS ARRAY<STRUCT<STRING, INT64>>)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_empty(MAP<STRING, INT64> input_map) -> BOOL)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT
  MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]), 'b', 2),
  MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]), 'b', 2, 'c', 3),
  MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'b', 2),
  MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'b', 2, 'c', 3);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
| +-$query.$col2#2 AS `$col2` [MAP<STRING, INT64>]
| +-$query.$col3#3 AS `$col3` [MAP<STRING, INT64>]
| +-$query.$col4#4 AS `$col4` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | |   +-Literal(type=STRING, value="c")
    | |   +-Literal(type=INT64, value=3)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col4#4 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=STRING, value="c")
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(
  MAP_FROM_ARRAY([('a', 1)]), 'b', 2, {{'c', 'x'|1, 3|'c'}});
--
ALTERNATION GROUP: 'c', 'x'
--
ERROR: No matching signature for function MAP_INSERT for argument types: MAP<STRING, INT64>, STRING, INT64, STRING, STRING. Supported signature: MAP_INSERT(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 1:8]
SELECT MAP_INSERT(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT
  Argument types: MAP<STRING, INT64>, STRING, INT64, STRING, STRING
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {INT64, INT64, STRING} [at 1:8]
SELECT MAP_INSERT(
       ^
--
ALTERNATION GROUP: 1, 3
--
ERROR: No matching signature for function MAP_INSERT for argument types: MAP<STRING, INT64>, STRING, INT64, INT64, INT64. Supported signature: MAP_INSERT(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 1:8]
SELECT MAP_INSERT(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT
  Argument types: MAP<STRING, INT64>, STRING, INT64, INT64, INT64
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING, STRING} [at 1:8]
SELECT MAP_INSERT(
       ^
--
ALTERNATION GROUP: 'c'
--
ERROR: Number of arguments does not match for function MAP_INSERT. Supported signature: MAP_INSERT(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 1:8]
SELECT MAP_INSERT(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT
  Argument types: MAP<STRING, INT64>, STRING, INT64, STRING
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Wrong number of repeated arguments provided. Expected a multiple of 2 but got 1 repeated argument [at 1:8]
SELECT MAP_INSERT(
       ^
--
ALTERNATION GROUP: _OR_REPLACE,'c', 'x'
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE for argument types: MAP<STRING, INT64>, STRING, INT64, STRING, STRING. Supported signature: MAP_INSERT_OR_REPLACE(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, INT64, STRING, STRING
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {INT64, INT64, STRING} [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(
       ^
--
ALTERNATION GROUP: _OR_REPLACE,1, 3
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE for argument types: MAP<STRING, INT64>, STRING, INT64, INT64, INT64. Supported signature: MAP_INSERT_OR_REPLACE(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, INT64, INT64, INT64
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING, STRING} [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(
       ^
--
ALTERNATION GROUP: _OR_REPLACE,'c'
--
ERROR: Number of arguments does not match for function MAP_INSERT_OR_REPLACE. Supported signature: MAP_INSERT_OR_REPLACE(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, INT64, STRING
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Wrong number of repeated arguments provided. Expected a multiple of 2 but got 1 repeated argument [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(
       ^
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(MAP_FROM_ARRAY([('a', 1)]))
--
ALTERNATION GROUP: <empty>
--
ERROR: Number of arguments does not match for function MAP_INSERT. Supported signature: MAP_INSERT(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 1:8]
SELECT MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]))
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT
  Argument types: MAP<STRING, INT64>
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Signature requires at least 3 arguments, found 1 argument [at 1:8]
SELECT MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]))
       ^
--
ALTERNATION GROUP: _OR_REPLACE
--
ERROR: Number of arguments does not match for function MAP_INSERT_OR_REPLACE. Supported signature: MAP_INSERT_OR_REPLACE(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]))
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: MAP<STRING, INT64>
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Signature requires at least 3 arguments, found 1 argument [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]))
       ^
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT
  MAP_INSERT(NULL, 'b', 2),
  MAP_INSERT(NULL, 'b', 2, 'c', 3),
  MAP_INSERT_OR_REPLACE(NULL, 'b', 2),
  MAP_INSERT_OR_REPLACE(NULL, 'b', 2, 'c', 3);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
| +-$query.$col2#2 AS `$col2` [MAP<STRING, INT64>]
| +-$query.$col3#3 AS `$col3` [MAP<STRING, INT64>]
| +-$query.$col4#4 AS `$col4` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-Literal(type=MAP<STRING, INT64>, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-Literal(type=MAP<STRING, INT64>, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | |   +-Literal(type=STRING, value="c")
    | |   +-Literal(type=INT64, value=3)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-Literal(type=MAP<STRING, INT64>, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col4#4 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL)
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=STRING, value="c")
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT MAP_INSERT{{|_OR_REPLACE}}(NULL, 'b', 2, {{1, 3|'c', 'x'}});
--
ALTERNATION GROUP: 1, 3
--
ERROR: No matching signature for function MAP_INSERT for argument types: NULL, STRING, INT64, INT64, INT64. Supported signature: MAP_INSERT(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 2:8]
SELECT MAP_INSERT(NULL, 'b', 2, 1, 3);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT
  Argument types: NULL, STRING, INT64, INT64, INT64
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING} [at 2:8]
SELECT MAP_INSERT(NULL, 'b', 2, 1, 3);
       ^
--
ALTERNATION GROUP: 'c', 'x'
--
ERROR: No matching signature for function MAP_INSERT for argument types: NULL, STRING, INT64, STRING, STRING. Supported signature: MAP_INSERT(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 2:8]
SELECT MAP_INSERT(NULL, 'b', 2, 'c', 'x');
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT
  Argument types: NULL, STRING, INT64, STRING, STRING
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {INT64, STRING} [at 2:8]
SELECT MAP_INSERT(NULL, 'b', 2, 'c', 'x');
       ^
--
ALTERNATION GROUP: _OR_REPLACE,1, 3
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE for argument types: NULL, STRING, INT64, INT64, INT64. Supported signature: MAP_INSERT_OR_REPLACE(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 2:8]
SELECT MAP_INSERT_OR_REPLACE(NULL, 'b', 2, 1, 3);
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: NULL, STRING, INT64, INT64, INT64
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING} [at 2:8]
SELECT MAP_INSERT_OR_REPLACE(NULL, 'b', 2, 1, 3);
       ^
--
ALTERNATION GROUP: _OR_REPLACE,'c', 'x'
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE for argument types: NULL, STRING, INT64, STRING, STRING. Supported signature: MAP_INSERT_OR_REPLACE(MAP, ANY, ANY, [[ANY, ANY], ...]) [at 2:8]
SELECT MAP_INSERT_OR_REPLACE(NULL, 'b', 2, 'c', 'x');
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: NULL, STRING, INT64, STRING, STRING
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {INT64, STRING} [at 2:8]
SELECT MAP_INSERT_OR_REPLACE(NULL, 'b', 2, 'c', 'x');
       ^
==

[no_java]
# TODO: Implement Java support for MAP value serialization.
SELECT MAP_INSERT{{|_OR_REPLACE}}(
  NULL, {{'a', 1|DATE('2024-01-01'), STRUCT()|NULL, NULL|NULL, NULL, 1.1, true}})
--
ALTERNATION GROUP: 'a', 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: DATE('2024-01-01'), STRUCT()
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, STRUCT<>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<DATE, STRUCT<>> input_map, DATE, STRUCT<>, repeated(0) DATE, repeated(0) STRUCT<>) -> MAP<DATE, STRUCT<>>)
    |     +-Literal(type=MAP<DATE, STRUCT<>>, value=NULL)
    |     +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     | +-Literal(type=TIMESTAMP, value=2024-01-01 08:00:00+00)
    |     +-Literal(type=STRUCT<>, value={})
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL, NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<INT64, INT64> input_map, INT64, INT64, repeated(0) INT64, repeated(0) INT64) -> MAP<INT64, INT64>)
    |     +-Literal(type=MAP<INT64, INT64>, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL, NULL, 1.1, true
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DOUBLE, BOOL>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<DOUBLE, BOOL> input_map, DOUBLE, BOOL, repeated(1) DOUBLE, repeated(1) BOOL) -> MAP<DOUBLE, BOOL>)
    |     +-Literal(type=MAP<DOUBLE, BOOL>, value=NULL)
    |     +-Literal(type=DOUBLE, value=NULL)
    |     +-Literal(type=BOOL, value=NULL)
    |     +-Literal(type=DOUBLE, value=1.1)
    |     +-Literal(type=BOOL, value=true)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE,'a', 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE,DATE('2024-01-01'), STRUCT()
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, STRUCT<>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<DATE, STRUCT<>> input_map, DATE, STRUCT<>, repeated(0) DATE, repeated(0) STRUCT<>) -> MAP<DATE, STRUCT<>>)
    |     +-Literal(type=MAP<DATE, STRUCT<>>, value=NULL)
    |     +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     | +-Literal(type=TIMESTAMP, value=2024-01-01 08:00:00+00)
    |     +-Literal(type=STRUCT<>, value={})
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE,NULL, NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<INT64, INT64> input_map, INT64, INT64, repeated(0) INT64, repeated(0) INT64) -> MAP<INT64, INT64>)
    |     +-Literal(type=MAP<INT64, INT64>, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE,NULL, NULL, 1.1, true
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DOUBLE, BOOL>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<DOUBLE, BOOL> input_map, DOUBLE, BOOL, repeated(1) DOUBLE, repeated(1) BOOL) -> MAP<DOUBLE, BOOL>)
    |     +-Literal(type=MAP<DOUBLE, BOOL>, value=NULL)
    |     +-Literal(type=DOUBLE, value=NULL)
    |     +-Literal(type=BOOL, value=NULL)
    |     +-Literal(type=DOUBLE, value=1.1)
    |     +-Literal(type=BOOL, value=true)
    +-input_scan=
      +-SingleRowScan
==

SELECT
  MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]), NULL, NULL, 'b', 2),
  MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]), 'b', 2, NULL, NULL),
  MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]), NULL, NULL, 'b', 2),
  MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'b', 2, NULL, NULL);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
| +-$query.$col2#2 AS `$col2` [MAP<STRING, INT64>]
| +-$query.$col3#3 AS `$col3` [MAP<STRING, INT64>]
| +-$query.$col4#4 AS `$col4` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=INT64, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=INT64, value=NULL)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=INT64, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col4#4 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(MAP_FROM_ARRAY([(DATE "2020-01-01", 1)]), "2020-01-02", 2);
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<DATE, INT64> input_map, DATE, INT64, repeated(0) DATE, repeated(0) INT64) -> MAP<DATE, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, INT64>>) -> MAP<DATE, INT64>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, INT64>) -> ARRAY<STRUCT<DATE, INT64>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, INT64>
    |     |     +-field_list=
    |     |       +-Literal(type=DATE, value=2020-01-01, has_explicit_type=TRUE)
    |     |       +-Literal(type=INT64, value=1)
    |     +-Literal(type=DATE, value=2020-01-02)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<DATE, INT64> input_map, DATE, INT64, repeated(0) DATE, repeated(0) INT64) -> MAP<DATE, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, INT64>>) -> MAP<DATE, INT64>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, INT64>) -> ARRAY<STRUCT<DATE, INT64>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, INT64>
    |     |     +-field_list=
    |     |       +-Literal(type=DATE, value=2020-01-01, has_explicit_type=TRUE)
    |     |       +-Literal(type=INT64, value=1)
    |     +-Literal(type=DATE, value=2020-01-02)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(MAP_FROM_ARRAY([(DATE "2020-01-01", 1)]), "2020-01-02", 2, "2020-01-03", 3);
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<DATE, INT64> input_map, DATE, INT64, repeated(1) DATE, repeated(1) INT64) -> MAP<DATE, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, INT64>>) -> MAP<DATE, INT64>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, INT64>) -> ARRAY<STRUCT<DATE, INT64>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, INT64>
    |     |     +-field_list=
    |     |       +-Literal(type=DATE, value=2020-01-01, has_explicit_type=TRUE)
    |     |       +-Literal(type=INT64, value=1)
    |     +-Literal(type=DATE, value=2020-01-02)
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=DATE, value=2020-01-03)
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<DATE, INT64> input_map, DATE, INT64, repeated(1) DATE, repeated(1) INT64) -> MAP<DATE, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, INT64>>) -> MAP<DATE, INT64>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, INT64>) -> ARRAY<STRUCT<DATE, INT64>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, INT64>
    |     |     +-field_list=
    |     |       +-Literal(type=DATE, value=2020-01-01, has_explicit_type=TRUE)
    |     |       +-Literal(type=INT64, value=1)
    |     +-Literal(type=DATE, value=2020-01-02)
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=DATE, value=2020-01-03)
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

