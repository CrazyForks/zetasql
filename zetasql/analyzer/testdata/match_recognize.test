[default language_features=V_1_4_MATCH_RECOGNIZE,TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY,ANALYTIC_FUNCTIONS,V_1_1_ORDER_BY_IN_AGGREGATE]
[default show_unparsed]
[default also_show_signature_mismatch_details]

[language_features=V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY{{|,V_1_4_MATCH_RECOGNIZE}}]
# In many of these basic cases, we're intentionally using:
# 1. SELECT *, to verify the output columns from MATCH_RECOGNIZE
# 2. Complex expressions over aggregates in the MEASURES clause to ensure they
#    are handled correctly (by an extra project scan)
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ALTERNATION GROUPS:
    key DESC
    key + 1 DESC NULLS FIRST
--
ERROR: MATCH_RECOGNIZE is not supported [at 5:24]
select * from KeyValue MATCH_RECOGNIZE(
                       ^
--
ALTERNATION GROUP: ,V_1_4_MATCH_RECOGNIZE,key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#5 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#5]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#5]
        +-expr_list=
        | +-m#5 :=
        |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#4)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#3, $agg2#4]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |       +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-$agg2#4 :=
                    +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  (matchrecognizescan_6.a_4) - (matchrecognizescan_6.a_5) AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1 DESC
    MEASURES
      MAX(LENGTH(keyvalue_3.a_2)) AS a_4,
      MIN(LENGTH(keyvalue_3.a_2)) AS a_5
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  B))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10,
      B AS(LENGTH(keyvalue_3.a_2)) >= 10
  )
  AS matchrecognizescan_6;
--
ALTERNATION GROUP: ,V_1_4_MATCH_RECOGNIZE,key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#6 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#6]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#6]
        +-expr_list=
        | +-m#6 :=
        |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#5)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#4, $agg2#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
            |   +-expr_list=
            |   | +-$orderbycol1#3 :=
            |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#4 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-$agg2#5 :=
                    +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  (matchrecognizescan_8.a_6) - (matchrecognizescan_8.a_7) AS m
FROM
  (
    SELECT
      keyvalue_3.a_1 AS a_1,
      keyvalue_3.a_2 AS a_2,
      (keyvalue_3.a_1) + 1 AS a_4
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  ) AS projectscan_5 MATCH_RECOGNIZE(
    ORDER BY projectscan_5.a_4 DESC NULLS FIRST
    MEASURES
      MAX(LENGTH(projectscan_5.a_2)) AS a_6,
      MIN(LENGTH(projectscan_5.a_2)) AS a_7
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  B))
    DEFINE
      A AS(LENGTH(projectscan_5.a_2)) < 10,
      B AS(LENGTH(projectscan_5.a_2)) >= 10
  )
  AS matchrecognizescan_8;
==

[language_features=V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY{{|,V_1_4_MATCH_RECOGNIZE}}]
# subquery
select * from (SELECT * FROM KeyValue) AS k MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ALTERNATION GROUPS:
    key DESC
    key + 1 DESC NULLS FIRST
--
ERROR: MATCH_RECOGNIZE is not supported [at 2:45]
select * from (SELECT * FROM KeyValue) AS k MATCH_RECOGNIZE(
                                            ^
--
ALTERNATION GROUP: ,V_1_4_MATCH_RECOGNIZE,key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#5 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#5]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#5]
        +-expr_list=
        | +-m#5 :=
        |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#4)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#3, $agg2#4]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=KeyValue.[Key#1, Value#2]
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |       +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-$agg2#4 :=
                    +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  (matchrecognizescan_6.a_4) - (matchrecognizescan_6.a_5) AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS projectscan_3 MATCH_RECOGNIZE(
    ORDER BY projectscan_3.a_1 DESC
    MEASURES
      MAX(LENGTH(projectscan_3.a_2)) AS a_4,
      MIN(LENGTH(projectscan_3.a_2)) AS a_5
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  B))
    DEFINE
      A AS(LENGTH(projectscan_3.a_2)) < 10,
      B AS(LENGTH(projectscan_3.a_2)) >= 10
  )
  AS matchrecognizescan_6;
--
ALTERNATION GROUP: ,V_1_4_MATCH_RECOGNIZE,key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#6 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#6]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#6]
        +-expr_list=
        | +-m#6 :=
        |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#5)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#4, $agg2#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
            |   +-expr_list=
            |   | +-$orderbycol1#3 :=
            |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-ProjectScan
            |       +-column_list=KeyValue.[Key#1, Value#2]
            |       +-input_scan=
            |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#4 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-$agg2#5 :=
                    +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  (matchrecognizescan_8.a_6) - (matchrecognizescan_8.a_7) AS m
FROM
  (
    SELECT
      projectscan_3.a_1 AS a_1,
      projectscan_3.a_2 AS a_2,
      (projectscan_3.a_1) + 1 AS a_4
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS projectscan_3
  ) AS projectscan_5 MATCH_RECOGNIZE(
    ORDER BY projectscan_5.a_4 DESC NULLS FIRST
    MEASURES
      MAX(LENGTH(projectscan_5.a_2)) AS a_6,
      MIN(LENGTH(projectscan_5.a_2)) AS a_7
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  B))
    DEFINE
      A AS(LENGTH(projectscan_5.a_2)) < 10,
      B AS(LENGTH(projectscan_5.a_2)) >= 10
  )
  AS matchrecognizescan_8;
==

[language_features=V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY{{|,V_1_4_MATCH_RECOGNIZE}}]
# UNNEST
select * from UNNEST(['abc', 'def']) AS value MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: MATCH_RECOGNIZE is not allowed with array scans [at 2:47]
select * from UNNEST(['abc', 'def']) AS value MATCH_RECOGNIZE(
                                              ^
==

[language_features=V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY{{|,V_1_4_MATCH_RECOGNIZE}}]
# 2 UNNESTs
select * from UNNEST([1, 2]) AS key, UNNEST(['abc', 'def']) AS value
MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: MATCH_RECOGNIZE is not allowed with array scans [at 3:1]
MATCH_RECOGNIZE(
^
==

[language_features=V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY{{|,V_1_4_MATCH_RECOGNIZE}}]
# Table with 2 UNNESTs
select * from UNNEST([1, 2]) AS key, UNNEST(['abc', 'def']) AS value
MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: MATCH_RECOGNIZE is not allowed with array scans [at 3:1]
MATCH_RECOGNIZE(
^
==

[language_features=TABLE_VALUED_FUNCTIONS,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY{{|,V_1_4_MATCH_RECOGNIZE}}]
# TVF
select * from tvf_no_args()
MATCH_RECOGNIZE(
  ORDER BY column_bool
  MEASURES max(length(column_bytes)) AS m
  PATTERN (a b)
  DEFINE
    A AS column_bool,
    B AS NOT column_bool
)
--
ALTERNATION GROUP: <empty>
--
ERROR: MATCH_RECOGNIZE is not supported [at 3:1]
MATCH_RECOGNIZE(
^
--
ALTERNATION GROUP: ,V_1_4_MATCH_RECOGNIZE
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TVFScan(column_list=tvf_no_args.[column_bool#1, column_bytes#2], tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=BOOL, column=tvf_no_args.column_bool#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-ColumnRef(type=BOOL, column=tvf_no_args.column_bool#1)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$not(BOOL) -> BOOL)
            |       +-ColumnRef(type=BOOL, column=tvf_no_args.column_bool#1)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(BYTES) -> INT64)
                        +-ColumnRef(type=BYTES, column=tvf_no_args.column_bytes#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS m
FROM
  (
    SELECT
      tvfscan_1.column_bool AS a_2,
      tvfscan_1.column_bytes AS a_3
    FROM
      TVF_NO_ARGS() AS tvfscan_1
  ) AS tvfscan_1 MATCH_RECOGNIZE(
    ORDER BY tvfscan_1.a_2
    MEASURES
      MAX(LENGTH(tvfscan_1.a_3)) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  B))
    DEFINE
      A AS tvfscan_1.a_2,
      B AS NOT(tvfscan_1.a_2)
  )
  AS matchrecognizescan_5;
==

[language_features=V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY{{|,V_1_4_MATCH_RECOGNIZE}}]
# parenthesized join
select * from (KeyValue t1 INNER JOIN KeyValue t2 ON t1.key = t2.key)
MATCH_RECOGNIZE(
  ORDER BY {{t1.key DESC|t1.key + 1 DESC NULLS FIRST}}
  MEASURES max(length(t2.value)) - min(length(t2.value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(t1.value) < 10,
    B AS length(t2.value) >= 10
)
--

ALTERNATION GROUPS:
    t1.key DESC
    t1.key + 1 DESC NULLS FIRST
--
ERROR: MATCH_RECOGNIZE is not supported [at 3:1]
MATCH_RECOGNIZE(
^
--
ALTERNATION GROUP: ,V_1_4_MATCH_RECOGNIZE,t1.key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 :=
        |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#5, $agg2#6]
            +-input_scan=
            | +-JoinScan
            |   +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
            |   +-left_scan=
            |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
            |   +-right_scan=
            |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="t2")
            |   +-join_expr=
            |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |       +-ColumnRef(type=INT64, column=KeyValue.Key#3)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |       +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#4)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#5 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |     +-ColumnRef(type=STRING, column=KeyValue.Value#4)
                  +-$agg2#6 :=
                    +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#4)

[UNPARSED_SQL]
SELECT
  (matchrecognizescan_10.a_8) - (matchrecognizescan_10.a_9) AS m
FROM
  (
    SELECT
      keyvalue_3.a_1 AS a_1,
      keyvalue_3.a_2 AS a_2,
      keyvalue_6.a_4 AS a_4,
      keyvalue_6.a_5 AS a_5
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
      INNER JOIN
      (
        SELECT
          KeyValue.Key AS a_4,
          KeyValue.Value AS a_5
        FROM
          KeyValue
      ) AS keyvalue_6
      ON (keyvalue_3.a_1) = (keyvalue_6.a_4)
  ) AS joinscan_7 MATCH_RECOGNIZE(
    ORDER BY joinscan_7.a_1 DESC
    MEASURES
      MAX(LENGTH(joinscan_7.a_5)) AS a_8,
      MIN(LENGTH(joinscan_7.a_5)) AS a_9
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  B))
    DEFINE
      A AS(LENGTH(joinscan_7.a_2)) < 10,
      B AS(LENGTH(joinscan_7.a_5)) >= 10
  )
  AS matchrecognizescan_10;
--
ALTERNATION GROUP: ,V_1_4_MATCH_RECOGNIZE,t1.key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#8 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#8]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#8]
        +-expr_list=
        | +-m#8 :=
        |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#7)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#6, $agg2#7]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, KeyValue.Key#3, KeyValue.Value#4, $orderby.$orderbycol1#5]
            |   +-expr_list=
            |   | +-$orderbycol1#5 :=
            |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-JoinScan
            |       +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
            |       +-left_scan=
            |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
            |       +-right_scan=
            |       | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="t2")
            |       +-join_expr=
            |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |           +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |           +-ColumnRef(type=INT64, column=KeyValue.Key#3)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#5)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#4)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#6 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |     +-ColumnRef(type=STRING, column=KeyValue.Value#4)
                  +-$agg2#7 :=
                    +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#4)

[UNPARSED_SQL]
SELECT
  (matchrecognizescan_11.a_9) - (matchrecognizescan_11.a_10) AS m
FROM
  (
    SELECT
      keyvalue_3.a_1 AS a_1,
      keyvalue_3.a_2 AS a_2,
      keyvalue_6.a_4 AS a_4,
      keyvalue_6.a_5 AS a_5,
      (keyvalue_3.a_1) + 1 AS a_7
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
      INNER JOIN
      (
        SELECT
          KeyValue.Key AS a_4,
          KeyValue.Value AS a_5
        FROM
          KeyValue
      ) AS keyvalue_6
      ON (keyvalue_3.a_1) = (keyvalue_6.a_4)
  ) AS projectscan_8 MATCH_RECOGNIZE(
    ORDER BY projectscan_8.a_7 DESC NULLS FIRST
    MEASURES
      MAX(LENGTH(projectscan_8.a_5)) AS a_9,
      MIN(LENGTH(projectscan_8.a_5)) AS a_10
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  B))
    DEFINE
      A AS(LENGTH(projectscan_8.a_2)) < 10,
      B AS(LENGTH(projectscan_8.a_5)) >= 10
  )
  AS matchrecognizescan_11;
==

[language_features=V_1_4_SQL_GRAPH,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY{{|,V_1_4_MATCH_RECOGNIZE}}]
select * from graph_table(aml MATCH (n) COLUMNS(n.age AS key, n.name AS value))
MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ALTERNATION GROUPS:
    key DESC
    key + 1 DESC NULLS FIRST
--
ERROR: MATCH_RECOGNIZE is not supported [at 2:1]
MATCH_RECOGNIZE(
^
--
ALTERNATION GROUP: ,V_1_4_MATCH_RECOGNIZE,key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#6 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#6]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#6]
        +-expr_list=
        | +-m#6 :=
        |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#5)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#4, $agg2#5]
            +-input_scan=
            | +-GraphTableScan
            |   +-column_list=$graph_table.[key#2, value#3]
            |   +-property_graph=sample_catalog.aml
            |   +-input_scan=
            |   | +-GraphScan
            |   |   +-column_list=[$element_table.n#1]
            |   |   +-input_scan_list=
            |   |     +-GraphPathScan
            |   |       +-column_list=[$element_table.n#1]
            |   |       +-input_scan_list=
            |   |       | +-GraphNodeScan
            |   |       |   +-column_list=[$element_table.n#1]
            |   |       |   +-label_expr=
            |   |       |   | +-GraphLabelNaryExpr
            |   |       |   |   +-op=OR
            |   |       |   |   +-operand_list=
            |   |       |   |     +-GraphWildCardLabel
            |   |       |   |     +-GraphLabelNaryExpr
            |   |       |   |       +-op=NOT
            |   |       |   |       +-operand_list=
            |   |       |   |         +-GraphWildCardLabel
            |   |       |   +-target_element_table_list=[sample_catalog.aml.Account,sample_catalog.aml.Person,sample_catalog.aml.Syndicate]
            |   |       +-head=$element_table.n#1
            |   |       +-tail=$element_table.n#1
            |   +-shape_expr_list=
            |     +-key#2 :=
            |     | +-GraphGetElementProperty
            |     |   +-type=UINT32
            |     |   +-expr=
            |     |   | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.n#1)
            |     |   +-property=age(UINT32)
            |     +-value#3 :=
            |       +-GraphGetElementProperty
            |         +-type=STRING
            |         +-expr=
            |         | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.n#1)
            |         +-property=name(STRING)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=UINT32, column=$graph_table.key#2)
            |       +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=$graph_table.value#3)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=$graph_table.value#3)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#4 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |     +-ColumnRef(type=STRING, column=$graph_table.value#3)
                  +-$agg2#5 :=
                    +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=$graph_table.value#3)

[UNPARSED_SQL]
SELECT
  (matchrecognizescan_8.a_6) - (matchrecognizescan_8.a_7) AS m
FROM
  (
    SELECT
      aml_1.a_3 AS a_3,
      aml_1.a_4 AS a_4
    FROM
      GRAPH_TABLE(
        aml
        MATCH
          (a_2
          IS (% | ! %))
        COLUMNS(
          a_2.age AS a_3,
          a_2.name AS a_4
        )
      ) AS aml_1
  ) AS graphtablescan_5 MATCH_RECOGNIZE(
    ORDER BY graphtablescan_5.a_3 DESC
    MEASURES
      MAX(LENGTH(graphtablescan_5.a_4)) AS a_6,
      MIN(LENGTH(graphtablescan_5.a_4)) AS a_7
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  B))
    DEFINE
      A AS(LENGTH(graphtablescan_5.a_4)) < 10,
      B AS(LENGTH(graphtablescan_5.a_4)) >= 10
  )
  AS matchrecognizescan_8;
--
ALTERNATION GROUP: ,V_1_4_MATCH_RECOGNIZE,key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 :=
        |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#5, $agg2#6]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[$graph_table.key#2, $graph_table.value#3, $orderby.$orderbycol1#4]
            |   +-expr_list=
            |   | +-$orderbycol1#4 :=
            |   |   +-FunctionCall(ZetaSQL:$add(UINT64, UINT64) -> UINT64)
            |   |     +-Cast(UINT32 -> UINT64)
            |   |     | +-ColumnRef(type=UINT32, column=$graph_table.key#2)
            |   |     +-Literal(type=UINT64, value=1)
            |   +-input_scan=
            |     +-GraphTableScan
            |       +-column_list=$graph_table.[key#2, value#3]
            |       +-property_graph=sample_catalog.aml
            |       +-input_scan=
            |       | +-GraphScan
            |       |   +-column_list=[$element_table.n#1]
            |       |   +-input_scan_list=
            |       |     +-GraphPathScan
            |       |       +-column_list=[$element_table.n#1]
            |       |       +-input_scan_list=
            |       |       | +-GraphNodeScan
            |       |       |   +-column_list=[$element_table.n#1]
            |       |       |   +-label_expr=
            |       |       |   | +-GraphLabelNaryExpr
            |       |       |   |   +-op=OR
            |       |       |   |   +-operand_list=
            |       |       |   |     +-GraphWildCardLabel
            |       |       |   |     +-GraphLabelNaryExpr
            |       |       |   |       +-op=NOT
            |       |       |   |       +-operand_list=
            |       |       |   |         +-GraphWildCardLabel
            |       |       |   +-target_element_table_list=[sample_catalog.aml.Account,sample_catalog.aml.Person,sample_catalog.aml.Syndicate]
            |       |       +-head=$element_table.n#1
            |       |       +-tail=$element_table.n#1
            |       +-shape_expr_list=
            |         +-key#2 :=
            |         | +-GraphGetElementProperty
            |         |   +-type=UINT32
            |         |   +-expr=
            |         |   | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.n#1)
            |         |   +-property=age(UINT32)
            |         +-value#3 :=
            |           +-GraphGetElementProperty
            |             +-type=STRING
            |             +-expr=
            |             | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.n#1)
            |             +-property=name(STRING)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=UINT64, column=$orderby.$orderbycol1#4)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=$graph_table.value#3)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=$graph_table.value#3)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#5 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |     +-ColumnRef(type=STRING, column=$graph_table.value#3)
                  +-$agg2#6 :=
                    +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=$graph_table.value#3)

[UNPARSED_SQL]
SELECT
  (matchrecognizescan_10.a_8) - (matchrecognizescan_10.a_9) AS m
FROM
  (
    SELECT
      graphtablescan_5.a_3 AS a_3,
      graphtablescan_5.a_4 AS a_4,
      CAST(graphtablescan_5.a_3 AS UINT64) + CAST(1 AS UINT64) AS a_6
    FROM
      (
        SELECT
          aml_1.a_3 AS a_3,
          aml_1.a_4 AS a_4
        FROM
          GRAPH_TABLE(
            aml
            MATCH
              (a_2
              IS (% | ! %))
            COLUMNS(
              a_2.age AS a_3,
              a_2.name AS a_4
            )
          ) AS aml_1
      ) AS graphtablescan_5
  ) AS projectscan_7 MATCH_RECOGNIZE(
    ORDER BY projectscan_7.a_6 DESC NULLS FIRST
    MEASURES
      MAX(LENGTH(projectscan_7.a_4)) AS a_8,
      MIN(LENGTH(projectscan_7.a_4)) AS a_9
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  B))
    DEFINE
      A AS(LENGTH(projectscan_7.a_4)) < 10,
      B AS(LENGTH(projectscan_7.a_4)) >= 10
  )
  AS matchrecognizescan_10;
==

# Predicates need to be boolean
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a)
  DEFINE
    A AS Key + 1
)
--
ERROR: MATCH_RECOGNIZE DEFINE predicate should return type BOOL, but returns INT64 [at 6:10]
    A AS Key + 1
         ^
==

# Cannot access pattern variables in the DEFINE clause. They also hide external
# range variables.
select * from KeyValue a MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(a.value) >= 10
)
--
ERROR: Cannot access columns through pattern variables. [at 7:17]
    B AS length(a.value) >= 10
                ^
==

# Can access range variables when not shadowed by pattern variables, both in
# the MEASURES and DEFINE clauses.
select * from KeyValue t MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES min(t.value) AS m
  PATTERN (a)
  DEFINE
    A AS length(t.value) > 10
)
--
ALTERNATION GROUP: key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t")
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |       +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1 DESC
    MEASURES
      MIN(keyvalue_3.a_2) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (A)
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) > 10
  )
  AS matchrecognizescan_5;
--
ALTERNATION GROUP: key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#5 AS m [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#5]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#5]
        +-expr_list=
        | +-m#5 := ColumnRef(type=STRING, column=$aggregate.$agg1#4)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#4]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
            |   +-expr_list=
            |   | +-$orderbycol1#3 :=
            |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t")
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#4 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_7.a_6 AS m
FROM
  (
    SELECT
      keyvalue_3.a_1 AS a_1,
      keyvalue_3.a_2 AS a_2,
      (keyvalue_3.a_1) + 1 AS a_4
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  ) AS projectscan_5 MATCH_RECOGNIZE(
    ORDER BY projectscan_5.a_4 DESC NULLS FIRST
    MEASURES
      MIN(projectscan_5.a_2) AS a_6
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (A)
    DEFINE
      A AS(LENGTH(projectscan_5.a_2)) > 10
  )
  AS matchrecognizescan_7;
==

# Error on variable used in PATTERN that has no entry in DEFINE
select * from KeyValue t MATCH_RECOGNIZE(
  ORDER BY key DESC
  MEASURES min(t.value) AS m
  PATTERN (a b)
  DEFINE
    A AS length(t.value) > 10
)
--
ERROR: Pattern variable `b` is not defined in the DEFINE clause [at 4:14]
  PATTERN (a b)
             ^
==

# Pattern variable names are case-insensitive and can be quoted.
select x, length(x) from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES min(value) AS x
  PATTERN ( A (b|`A`) `x` `$ #` a )
  DEFINE
    a AS length(value) < 10,
    B AS length(value) >= 10,
    x AS true,
    `$ #` AS true
)
--
ALTERNATION GROUP: key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#4 AS x [STRING]
| +-$query.$col2#5 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#4, $query.$col2#5]
    +-expr_list=
    | +-$col2#5 :=
    |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
    |     +-ColumnRef(type=STRING, column=$match_recognize.x#4)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#4]
        +-expr_list=
        | +-x#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |       +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="a"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            | | +-name="B"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            | | +-name="x"
            | | +-predicate=
            | |   +-Literal(type=BOOL, value=true)
            | +-MatchRecognizeVariableDefinition
            |   +-name="$ #"
            |   +-predicate=
            |     +-Literal(type=BOOL, value=true)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="a")
            |     +-MatchRecognizePatternOperation
            |     | +-op_type=ALTERNATE
            |     | +-operand_list=
            |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     |   +-MatchRecognizePatternVariableRef(name="a")
            |     +-MatchRecognizePatternVariableRef(name="x")
            |     +-MatchRecognizePatternVariableRef(name="$ #")
            |     +-MatchRecognizePatternVariableRef(name="a")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  projectscan_7.a_6 AS x,
  LENGTH(projectscan_7.a_6) AS a_8
FROM
  (
    SELECT
      matchrecognizescan_5.a_4 AS a_6
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3 MATCH_RECOGNIZE(
        ORDER BY keyvalue_3.a_1 DESC
        MEASURES
          MIN(keyvalue_3.a_2) AS a_4
        AFTER MATCH SKIP PAST LAST ROW
        PATTERN ((a  (B | a)  x  `$ #`  a))
        DEFINE
          a AS(LENGTH(keyvalue_3.a_2)) < 10,
          B AS(LENGTH(keyvalue_3.a_2)) >= 10,
          x AS true,
          `$ #` AS true
      )
      AS matchrecognizescan_5
  ) AS projectscan_7;
--
ALTERNATION GROUP: key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#5 AS x [STRING]
| +-$query.$col2#6 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#5, $query.$col2#6]
    +-expr_list=
    | +-$col2#6 :=
    |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
    |     +-ColumnRef(type=STRING, column=$match_recognize.x#5)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#5]
        +-expr_list=
        | +-x#5 := ColumnRef(type=STRING, column=$aggregate.$agg1#4)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#4]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
            |   +-expr_list=
            |   | +-$orderbycol1#3 :=
            |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="a"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            | | +-name="B"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            | | +-name="x"
            | | +-predicate=
            | |   +-Literal(type=BOOL, value=true)
            | +-MatchRecognizeVariableDefinition
            |   +-name="$ #"
            |   +-predicate=
            |     +-Literal(type=BOOL, value=true)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="a")
            |     +-MatchRecognizePatternOperation
            |     | +-op_type=ALTERNATE
            |     | +-operand_list=
            |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     |   +-MatchRecognizePatternVariableRef(name="a")
            |     +-MatchRecognizePatternVariableRef(name="x")
            |     +-MatchRecognizePatternVariableRef(name="$ #")
            |     +-MatchRecognizePatternVariableRef(name="a")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#4 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  projectscan_9.a_8 AS x,
  LENGTH(projectscan_9.a_8) AS a_10
FROM
  (
    SELECT
      matchrecognizescan_7.a_6 AS a_8
    FROM
      (
        SELECT
          keyvalue_3.a_1 AS a_1,
          keyvalue_3.a_2 AS a_2,
          (keyvalue_3.a_1) + 1 AS a_4
        FROM
          (
            SELECT
              KeyValue.Key AS a_1,
              KeyValue.Value AS a_2
            FROM
              KeyValue
          ) AS keyvalue_3
      ) AS projectscan_5 MATCH_RECOGNIZE(
        ORDER BY projectscan_5.a_4 DESC NULLS FIRST
        MEASURES
          MIN(projectscan_5.a_2) AS a_6
        AFTER MATCH SKIP PAST LAST ROW
        PATTERN ((a  (B | a)  x  `$ #`  a))
        DEFINE
          a AS(LENGTH(projectscan_5.a_2)) < 10,
          B AS(LENGTH(projectscan_5.a_2)) >= 10,
          x AS true,
          `$ #` AS true
      )
      AS matchrecognizescan_7
  ) AS projectscan_9;
==

# Duplicate definition is an error, even if identical
select x, length(x) from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES min(value) AS x
  PATTERN ( A )
  DEFINE
    a AS length(value) < 10,
    a AS length(value) < 10
)
--
ERROR: Pattern variable `a` is defined multiple times [at 7:5]
    a AS length(value) < 10
    ^
==

# Error on unused variable
select x, length(x) from KeyValue MATCH_RECOGNIZE(
  ORDER BY key DESC
  MEASURES min(value) AS x
  PATTERN ( A )
  DEFINE
    a AS length(value) < 10,
    b AS length(value) >= 10
)
--
ERROR: Pattern variable `b` is defined but not used in the pattern [at 7:5]
    b AS length(value) >= 10
    ^
==

# On an operand of a join, with alternation
select x, length(x) from
  KeyValue MATCH_RECOGNIZE(
    ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
    MEASURES min(value) AS x
    PATTERN ( A (B|A) X A )
    DEFINE
      A AS length(value) < 10,
      B AS length(value) >= 10,
      X AS true
  ) AS m1
INNER JOIN KeyValue
ON m1.x = value
--
ALTERNATION GROUP: key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#4 AS x [STRING]
| +-$query.$col2#7 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#4, $query.$col2#7]
    +-expr_list=
    | +-$col2#7 :=
    |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
    |     +-ColumnRef(type=STRING, column=$match_recognize.x#4)
    +-input_scan=
      +-JoinScan
        +-column_list=[$match_recognize.x#4, KeyValue.Value#6]
        +-left_scan=
        | +-ProjectScan
        |   +-column_list=[$match_recognize.x#4]
        |   +-expr_list=
        |   | +-x#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        |   +-input_scan=
        |     +-MatchRecognizeScan
        |       +-column_list=[$aggregate.$agg1#3]
        |       +-input_scan=
        |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |       +-order_by=
        |       | +-WindowOrdering
        |       |   +-order_by_item_list=
        |       |     +-OrderByItem
        |       |       +-column_ref=
        |       |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       |       +-is_descending=TRUE
        |       +-pattern_variable_definition_list=
        |       | +-MatchRecognizeVariableDefinition
        |       | | +-name="A"
        |       | | +-predicate=
        |       | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |       | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
        |       | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | |     +-Literal(type=INT64, value=10)
        |       | +-MatchRecognizeVariableDefinition
        |       | | +-name="B"
        |       | | +-predicate=
        |       | |   +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
        |       | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
        |       | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | |     +-Literal(type=INT64, value=10)
        |       | +-MatchRecognizeVariableDefinition
        |       |   +-name="X"
        |       |   +-predicate=
        |       |     +-Literal(type=BOOL, value=true)
        |       +-pattern=
        |       | +-MatchRecognizePatternOperation
        |       |   +-op_type=CONCAT
        |       |   +-operand_list=
        |       |     +-MatchRecognizePatternVariableRef(name="A")
        |       |     +-MatchRecognizePatternOperation
        |       |     | +-op_type=ALTERNATE
        |       |     | +-operand_list=
        |       |     |   +-MatchRecognizePatternVariableRef(name="B")
        |       |     |   +-MatchRecognizePatternVariableRef(name="A")
        |       |     +-MatchRecognizePatternVariableRef(name="X")
        |       |     +-MatchRecognizePatternVariableRef(name="A")
        |       +-after_match_skip_mode=END_OF_MATCH
        |       +-measure_group_list=
        |         +-MeasureGroup
        |           +-aggregate_list=
        |             +-$agg1#3 :=
        |               +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
        |                 +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-right_scan=
        | +-TableScan(column_list=[KeyValue.Value#6], table=KeyValue, column_index_list=[1])
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=$match_recognize.x#4)
            +-ColumnRef(type=STRING, column=KeyValue.Value#6)

[UNPARSED_SQL]
SELECT
  projectscan_7.a_6 AS x,
  LENGTH(projectscan_7.a_6) AS a_10
FROM
  (
    SELECT
      matchrecognizescan_5.a_4 AS a_6
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3 MATCH_RECOGNIZE(
        ORDER BY keyvalue_3.a_1 DESC
        MEASURES
          MIN(keyvalue_3.a_2) AS a_4
        AFTER MATCH SKIP PAST LAST ROW
        PATTERN ((A  (B | A)  X  A))
        DEFINE
          A AS(LENGTH(keyvalue_3.a_2)) < 10,
          B AS(LENGTH(keyvalue_3.a_2)) >= 10,
          X AS true
      )
      AS matchrecognizescan_5
  ) AS projectscan_7
  INNER JOIN
  (
    SELECT
      KeyValue.Value AS a_8
    FROM
      KeyValue
  ) AS keyvalue_9
  ON (projectscan_7.a_6) = (keyvalue_9.a_8);
--
ALTERNATION GROUP: key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#5 AS x [STRING]
| +-$query.$col2#8 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#5, $query.$col2#8]
    +-expr_list=
    | +-$col2#8 :=
    |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
    |     +-ColumnRef(type=STRING, column=$match_recognize.x#5)
    +-input_scan=
      +-JoinScan
        +-column_list=[$match_recognize.x#5, KeyValue.Value#7]
        +-left_scan=
        | +-ProjectScan
        |   +-column_list=[$match_recognize.x#5]
        |   +-expr_list=
        |   | +-x#5 := ColumnRef(type=STRING, column=$aggregate.$agg1#4)
        |   +-input_scan=
        |     +-MatchRecognizeScan
        |       +-column_list=[$aggregate.$agg1#4]
        |       +-input_scan=
        |       | +-ProjectScan
        |       |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
        |       |   +-expr_list=
        |       |   | +-$orderbycol1#3 :=
        |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       |   |     +-Literal(type=INT64, value=1)
        |       |   +-input_scan=
        |       |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |       +-order_by=
        |       | +-WindowOrdering
        |       |   +-order_by_item_list=
        |       |     +-OrderByItem
        |       |       +-column_ref=
        |       |       | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
        |       |       +-is_descending=TRUE
        |       |       +-null_order=NULLS_FIRST
        |       +-pattern_variable_definition_list=
        |       | +-MatchRecognizeVariableDefinition
        |       | | +-name="A"
        |       | | +-predicate=
        |       | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |       | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
        |       | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | |     +-Literal(type=INT64, value=10)
        |       | +-MatchRecognizeVariableDefinition
        |       | | +-name="B"
        |       | | +-predicate=
        |       | |   +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
        |       | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
        |       | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | |     +-Literal(type=INT64, value=10)
        |       | +-MatchRecognizeVariableDefinition
        |       |   +-name="X"
        |       |   +-predicate=
        |       |     +-Literal(type=BOOL, value=true)
        |       +-pattern=
        |       | +-MatchRecognizePatternOperation
        |       |   +-op_type=CONCAT
        |       |   +-operand_list=
        |       |     +-MatchRecognizePatternVariableRef(name="A")
        |       |     +-MatchRecognizePatternOperation
        |       |     | +-op_type=ALTERNATE
        |       |     | +-operand_list=
        |       |     |   +-MatchRecognizePatternVariableRef(name="B")
        |       |     |   +-MatchRecognizePatternVariableRef(name="A")
        |       |     +-MatchRecognizePatternVariableRef(name="X")
        |       |     +-MatchRecognizePatternVariableRef(name="A")
        |       +-after_match_skip_mode=END_OF_MATCH
        |       +-measure_group_list=
        |         +-MeasureGroup
        |           +-aggregate_list=
        |             +-$agg1#4 :=
        |               +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
        |                 +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-right_scan=
        | +-TableScan(column_list=[KeyValue.Value#7], table=KeyValue, column_index_list=[1])
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=$match_recognize.x#5)
            +-ColumnRef(type=STRING, column=KeyValue.Value#7)

[UNPARSED_SQL]
SELECT
  projectscan_9.a_8 AS x,
  LENGTH(projectscan_9.a_8) AS a_12
FROM
  (
    SELECT
      matchrecognizescan_7.a_6 AS a_8
    FROM
      (
        SELECT
          keyvalue_3.a_1 AS a_1,
          keyvalue_3.a_2 AS a_2,
          (keyvalue_3.a_1) + 1 AS a_4
        FROM
          (
            SELECT
              KeyValue.Key AS a_1,
              KeyValue.Value AS a_2
            FROM
              KeyValue
          ) AS keyvalue_3
      ) AS projectscan_5 MATCH_RECOGNIZE(
        ORDER BY projectscan_5.a_4 DESC NULLS FIRST
        MEASURES
          MIN(projectscan_5.a_2) AS a_6
        AFTER MATCH SKIP PAST LAST ROW
        PATTERN ((A  (B | A)  X  A))
        DEFINE
          A AS(LENGTH(projectscan_5.a_2)) < 10,
          B AS(LENGTH(projectscan_5.a_2)) >= 10,
          X AS true
      )
      AS matchrecognizescan_7
  ) AS projectscan_9
  INNER JOIN
  (
    SELECT
      KeyValue.Value AS a_10
    FROM
      KeyValue
  ) AS keyvalue_11
  ON (projectscan_9.a_8) = (keyvalue_11.a_10);
==

# Aggregation in DEFINE clause is not yet supported
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( A )
  DEFINE
    A AS value > MAX(value)
)
--

ERROR: Aggregate function MAX not allowed in MATCH_RECOGNIZE DEFINE predicate [at 6:18]
    A AS value > MAX(value)
                 ^
==

# Conditional evaluation is not yet supported
# Conditional on the whole MATCH_RECOGNIZE operation
[language_features=V_1_4_MATCH_RECOGNIZE,V_1_4_ENFORCE_CONDITIONAL_EVALUATION]
SELECT IF(key = 0, NULL,
        (select * from KeyValue MATCH_RECOGNIZE(
          ORDER BY 1/outer_tbl.key        # Could be a div by zero error
          MEASURES min(value) AS x
          PATTERN ( A B )
          DEFINE
            A AS length(value) < 10,
            B AS length(value) >= 10
        )))
FROM KeyValue outer_tbl
--
ERROR: Conditional evaluation is not supported with MATCH_RECOGNIZE [at 2:33]
        (select * from KeyValue MATCH_RECOGNIZE(
                                ^
==

# Conditional evaluation is not yet supported
# Conditional on aggregations in the MATCH_RECOGNIZE clause
[language_features=V_1_4_MATCH_RECOGNIZE,V_1_4_ENFORCE_CONDITIONAL_EVALUATION]
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY 1/key
  MEASURES IF(min(length(value)) > 0, min(1/length(value)), NULL) AS x
  PATTERN ( A B )
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: Conditional evaluation is not supported with MATCH_RECOGNIZE [at 3:15]
  MEASURES IF(min(length(value)) > 0, min(1/length(value)), NULL) AS x
              ^
==

# Unaggregated column in MEASURES in the default ONE ROW PER MATCH mode.
select * from KeyValue t MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES {{|t.|A.}}value AS x
  PATTERN ( A )
  DEFINE
    A AS true
)
--
ALTERNATION GROUP: <empty>
--
ERROR: MATCH_RECOGNIZE MEASURES clause expression references column value which is neither grouped nor aggregated [at 3:12]
  MEASURES value AS x
           ^
--
ALTERNATION GROUP: t.
--
ERROR: MATCH_RECOGNIZE MEASURES clause expression references t.value which is neither grouped nor aggregated [at 3:12]
  MEASURES t.value AS x
           ^
--
ALTERNATION GROUP: A.
--
ERROR: Cannot access columns through pattern variables. [at 3:12]
  MEASURES A.value AS x
           ^
==

# Empty pattern as operand to quantification & other operations
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( ()+ a () (a|) )
  DEFINE
    A AS length(value) < 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#4 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#4]
        +-expr_list=
        | +-x#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternEmpty
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternEmpty
            |     +-MatchRecognizePatternOperation
            |       +-op_type=ALTERNATE
            |       +-operand_list=
            |         +-MatchRecognizePatternVariableRef(name="A")
            |         +-MatchRecognizePatternEmpty
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS x
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MIN(keyvalue_3.a_2) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (((( ) { 1, })  A  ( )  (A |( ))))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
  )
  AS matchrecognizescan_5;
==

# Reluctant ? vs nested ?s
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( (a?)? )
  DEFINE
    A AS length(value) < 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#4 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#4]
        +-expr_list=
        | +-x#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternQuantification
            |   +-operand=
            |   | +-MatchRecognizePatternQuantification
            |   |   +-operand=
            |   |   | +-MatchRecognizePatternVariableRef(name="A")
            |   |   +-lower_bound=
            |   |   | +-Literal(type=INT64, value=0)
            |   |   +-upper_bound=
            |   |   | +-Literal(type=INT64, value=1)
            |   |   +-is_reluctant=FALSE
            |   +-lower_bound=
            |   | +-Literal(type=INT64, value=0)
            |   +-upper_bound=
            |   | +-Literal(type=INT64, value=1)
            |   +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS x
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MIN(keyvalue_3.a_2) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (((A { 0, 1 }) { 0, 1 }))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
  )
  AS matchrecognizescan_5;
==

# Quantified patterns: Symbol quantifiers
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a+ (b)+? (a|)* (a|()b)*? a? b?? )
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#4 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#4]
        +-expr_list=
        | +-x#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="B")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternOperation
            |     | |   +-op_type=ALTERNATE
            |     | |   +-operand_list=
            |     | |     +-MatchRecognizePatternVariableRef(name="A")
            |     | |     +-MatchRecognizePatternEmpty
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternOperation
            |     | |   +-op_type=ALTERNATE
            |     | |   +-operand_list=
            |     | |     +-MatchRecognizePatternVariableRef(name="A")
            |     | |     +-MatchRecognizePatternOperation
            |     | |       +-op_type=CONCAT
            |     | |       +-operand_list=
            |     | |         +-MatchRecognizePatternEmpty
            |     | |         +-MatchRecognizePatternVariableRef(name="B")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-upper_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="B")
            |       +-lower_bound=
            |       | +-Literal(type=INT64, value=0)
            |       +-upper_bound=
            |       | +-Literal(type=INT64, value=1)
            |       +-is_reluctant=TRUE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS x
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MIN(keyvalue_3.a_2) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (((A { 1, })  (B { 1, } ?)  ((A |( )) { 0, })  ((A |(( )  B)) { 0, } ?)  (A { 0, 1 })  (B { 0, 1 } ?)))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10,
      B AS(LENGTH(keyvalue_3.a_2)) >= 10
  )
  AS matchrecognizescan_5;
==

[parameter_mode=positional]
[positional_parameter_types=int64,int64]
# Quantified patterns: Fixed quantifiers - Dedicated case for positional params
# Note how each quantifier has both of its bounds set to the same parameter.
# But the referenced parameters are different between the quantifiers.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{?} (a{?}) )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#4 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#4]
        +-expr_list=
        | +-x#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Parameter(type=INT64, position=1)
            |     | +-upper_bound=
            |     | | +-Parameter(type=INT64, position=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="A")
            |       +-lower_bound=
            |       | +-Parameter(type=INT64, position=2)
            |       +-upper_bound=
            |       | +-Parameter(type=INT64, position=2)
            |       +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS x
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MIN(keyvalue_3.a_2) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (((A { ? })  (A { ? })))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
  )
  AS matchrecognizescan_5;
==

# This is a syntax error. This test is here to protect against regressions.
# If the syntax starts allowing richer syntax, even CAST(? AS INT64), the logic
# for SqlBuilder, which needs to avoid printing A{?} as A{?, ?} will break
# because it's hard to match general expressions.
[parameter_mode=positional]
[positional_parameter_types=int64,int64]
# Quantified patterns: Fixed quantifiers - Dedicated case for positional params
# Note how each quantifier has both of its bounds set to the same parameter.
# But the referenced parameters are different between the quantifiers.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{? + 1} )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Syntax error: Expected "," but got "+" [at 7:17]
  PATTERN ( a{? + 1} )
                ^
==

# This is a syntax error. This test is here to protect against regressions.
# If the syntax starts allowing richer syntax, even CAST(? AS INT64), the logic
# for SqlBuilder, which needs to avoid printing A{?} as A{?, ?} will break
# because it's hard to match general expressions.
[parameter_mode=positional]
[positional_parameter_types=int64,int64]
# Quantified patterns: Fixed quantifiers - Dedicated case for positional params
# Note how each quantifier has both of its bounds set to the same parameter.
# But the referenced parameters are different between the quantifiers.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{CAST(? AS INT64)} )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Syntax error: Expected "," but got keyword CAST [at 7:15]
  PATTERN ( a{CAST(? AS INT64)} )
              ^
==

# Quantified patterns: 2-bounded quantifiers
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{1, @test_param_int64} a{2, 4}? (a|b()b|){ , }? b{@test_param_int64, }? a { , 3} )
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#4 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#4]
        +-expr_list=
        | +-x#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-upper_bound=
            |     | | +-Parameter(type=INT64, name="test_param_int64")
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=2)
            |     | +-upper_bound=
            |     | | +-Literal(type=INT64, value=4)
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternOperation
            |     | |   +-op_type=ALTERNATE
            |     | |   +-operand_list=
            |     | |     +-MatchRecognizePatternVariableRef(name="A")
            |     | |     +-MatchRecognizePatternOperation
            |     | |     | +-op_type=CONCAT
            |     | |     | +-operand_list=
            |     | |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     | |     |   +-MatchRecognizePatternEmpty
            |     | |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     | |     +-MatchRecognizePatternEmpty
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="B")
            |     | +-lower_bound=
            |     | | +-Parameter(type=INT64, name="test_param_int64")
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="A")
            |       +-lower_bound=
            |       | +-Literal(type=INT64, value=0)
            |       +-upper_bound=
            |       | +-Literal(type=INT64, value=3)
            |       +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS x
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MIN(keyvalue_3.a_2) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (((A { 1, @test_param_int64 })  (A { 2, 4 } ?)  ((A |(B  ( )  B) |( )) { 0, } ?)  (B { @test_param_int64, } ?)  (A { 0, 3 })))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10,
      B AS(LENGTH(keyvalue_3.a_2)) >= 10
  )
  AS matchrecognizescan_5;
==

# Quantified patterns: Fixed quantifiers
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{1} (a|b()b|){@test_param_int64} a{ 0xaF } )
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#4 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#4]
        +-expr_list=
        | +-x#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-upper_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternOperation
            |     | |   +-op_type=ALTERNATE
            |     | |   +-operand_list=
            |     | |     +-MatchRecognizePatternVariableRef(name="A")
            |     | |     +-MatchRecognizePatternOperation
            |     | |     | +-op_type=CONCAT
            |     | |     | +-operand_list=
            |     | |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     | |     |   +-MatchRecognizePatternEmpty
            |     | |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     | |     +-MatchRecognizePatternEmpty
            |     | +-lower_bound=
            |     | | +-Parameter(type=INT64, name="test_param_int64")
            |     | +-upper_bound=
            |     | | +-Parameter(type=INT64, name="test_param_int64")
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="A")
            |       +-lower_bound=
            |       | +-Literal(type=INT64, value=175)
            |       +-upper_bound=
            |       | +-Literal(type=INT64, value=175)
            |       +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS x
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MIN(keyvalue_3.a_2) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (((A { 1, 1 })  ((A |(B  ( )  B) |( )) { @test_param_int64, @test_param_int64 })  (A { 175, 175 })))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10,
      B AS(LENGTH(keyvalue_3.a_2)) >= 10
  )
  AS matchrecognizescan_5;
==

# Quantifier bound must be a literal or parameter
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{1+1} )
  DEFINE
    A AS length(value) < 10
)
--

ERROR: Syntax error: Expected "," but got "+" [at 4:16]
  PATTERN ( a{1+1} )
               ^
==

# Quantifiers with negative values. This is repeating a case in parser tests
# to catch potential regressions if the syntax is relaxed.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{-1} )
  DEFINE
    A AS length(value) < 10
)
--

ERROR: Syntax error: Expected "," but got "-" [at 4:15]
  PATTERN ( a{-1} )
              ^
==

# Quantifier bound of the wrong type, or NULL
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{ {{NULL|@test_param_bool|@test_param_string|1.6|CAST(1 AS UINT32)}} } )
  DEFINE
    A AS length(value) < 10
)
--

ALTERNATION GROUP: NULL
--
ERROR: Syntax error: Expected "," but got keyword NULL [at 4:16]
  PATTERN ( a{ NULL } )
               ^
--
ALTERNATION GROUP: @test_param_bool
--
ERROR: MATCH_RECOGNIZE quantifier bound expects an integer literal or parameter [at 4:16]
  PATTERN ( a{ @test_param_bool } )
               ^
--
ALTERNATION GROUP: @test_param_string
--
ERROR: MATCH_RECOGNIZE quantifier bound expects an integer literal or parameter [at 4:16]
  PATTERN ( a{ @test_param_string } )
               ^
--
ALTERNATION GROUP: 1.6
--
ERROR: Syntax error: Expected "," but got floating point literal "1.6" [at 4:16]
  PATTERN ( a{ 1.6 } )
               ^
--
ALTERNATION GROUP: CAST(1 AS UINT32)
--
ERROR: Syntax error: Expected "," but got keyword CAST [at 4:16]
  PATTERN ( a{ CAST(1 AS UINT32) } )
               ^
==

# Quantifiers with bad values, detectable because both are literals.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{3, 1} )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Quantifier upper bound cannot be smaller than the lower bound [at 4:14]
  PATTERN ( a{3, 1} )
             ^
==

# ORDER BY cannot have aggregations, analytic functions, nor ordinals.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{max(key)|max(key) OVER(ORDER BY value)|1}}
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
ALTERNATION GROUP: max(key)
--
ERROR: Aggregate function MAX not allowed in MATCH_RECOGNIZE ORDER BY clause [at 2:12]
  ORDER BY max(key)
           ^
--
ALTERNATION GROUP: max(key) OVER(ORDER BY value)
--
ERROR: Analytic function not allowed in MATCH_RECOGNIZE ORDER BY clause [at 2:12]
  ORDER BY max(key) OVER(ORDER BY value)
           ^
--
ALTERNATION GROUP: 1
--
ERROR: Ordinals are not allowed in MATCH_RECOGNIZE ORDER BY clause [at 2:12]
  ORDER BY 1
           ^
==

[language_features=V_1_4_MATCH_RECOGNIZE,JSON_TYPE]
# ORDER BY expressions must be of an orderable type. JSON is not orderable.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY JSON'{"f":1}'
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Ordering by expressions of type JSON is not allowed [at 3:12]
  ORDER BY JSON'{"f":1}'
           ^
==

[language_features=V_1_4_MATCH_RECOGNIZE,V_1_1_ORDER_BY_COLLATE]
# ORDER BY with collation
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value COLLATE "en_US"
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#4 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#4]
        +-expr_list=
        | +-x#4 := ColumnRef(type=STRING, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-collation_name=
            |         +-Literal(type=STRING, value="en_US")
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_4.a_3 AS x
FROM
  (
    SELECT
      KeyValue.Value AS a_1
    FROM
      KeyValue
  ) AS keyvalue_2 MATCH_RECOGNIZE(
    ORDER BY keyvalue_2.a_1 COLLATE "en_US"
    MEASURES
      MIN(keyvalue_2.a_1) AS a_3
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_2.a_1)) < 10
  )
  AS matchrecognizescan_4;
==

# Computed partitioning columns
# TODO: PARTITION BY..AS syntax (esp with the alias covering an input column)
select * from KeyValue MATCH_RECOGNIZE(
  PARTITION BY key * 2
  ORDER BY value || value
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$partitionby.$partitionbycol1#3 AS `$partition_by_col1` [INT64]
| +-$match_recognize.x#6 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$partitionby.$partitionbycol1#3, $match_recognize.x#6]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$partitionby.$partitionbycol1#3, $match_recognize.x#6]
        +-expr_list=
        | +-x#6 := ColumnRef(type=STRING, column=$aggregate.$agg1#5)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$partitionby.$partitionbycol1#3, $aggregate.$agg1#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.$partitionbycol1#3, $orderby.$orderbycol1#4]
            |   +-expr_list=
            |   | +-$partitionbycol1#3 :=
            |   | | +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
            |   | |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | |   +-Literal(type=INT64, value=2)
            |   | +-$orderbycol1#4 :=
            |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol1#3)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#4)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#5 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_8.a_4 AS a_4,
  matchrecognizescan_8.a_7 AS x
FROM
  (
    SELECT
      keyvalue_3.a_1 AS a_1,
      keyvalue_3.a_2 AS a_2,
      (keyvalue_3.a_1) * 2 AS a_4,
      CONCAT(keyvalue_3.a_2, keyvalue_3.a_2) AS a_5
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  ) AS projectscan_6 MATCH_RECOGNIZE(
    PARTITION BY projectscan_6.a_4
    ORDER BY projectscan_6.a_5
    MEASURES
      MIN(projectscan_6.a_2) AS a_7
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(projectscan_6.a_2)) < 10
  )
  AS matchrecognizescan_8;
==

select key, x from KeyValue MATCH_RECOGNIZE(
  PARTITION BY key
  ORDER BY value || value
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$partitionby.key#3 AS key [INT64]
| +-$match_recognize.x#6 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$partitionby.key#3, $match_recognize.x#6]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$partitionby.key#3, $match_recognize.x#6]
        +-expr_list=
        | +-x#6 := ColumnRef(type=STRING, column=$aggregate.$agg1#5)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$partitionby.key#3, $aggregate.$agg1#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.key#3, $orderby.$orderbycol1#4]
            |   +-expr_list=
            |   | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | +-$orderbycol1#4 :=
            |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$partitionby.key#3)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#4)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#5 :=
                    +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_8.a_4 AS key,
  matchrecognizescan_8.a_7 AS x
FROM
  (
    SELECT
      keyvalue_3.a_1 AS a_1,
      keyvalue_3.a_2 AS a_2,
      keyvalue_3.a_1 AS a_4,
      CONCAT(keyvalue_3.a_2, keyvalue_3.a_2) AS a_5
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  ) AS projectscan_6 MATCH_RECOGNIZE(
    PARTITION BY projectscan_6.a_4
    ORDER BY projectscan_6.a_5
    MEASURES
      MIN(projectscan_6.a_2) AS a_7
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(projectscan_6.a_2)) < 10
  )
  AS matchrecognizescan_8;
==

# PARTITION BY cannot have aggregations, analytic functions, nor ordinals.
select * from KeyValue MATCH_RECOGNIZE(
  PARTITION BY {{max(key)|max(key) OVER(ORDER BY value)|1}}
  ORDER BY value
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
ALTERNATION GROUP: max(key)
--
ERROR: Aggregate function MAX not allowed in MATCH_RECOGNIZE PARTITION BY clause [at 2:16]
  PARTITION BY max(key)
               ^
--
ALTERNATION GROUP: max(key) OVER(ORDER BY value)
--
ERROR: Analytic function not allowed in MATCH_RECOGNIZE PARTITION BY clause [at 2:16]
  PARTITION BY max(key) OVER(ORDER BY value)
               ^
--
ALTERNATION GROUP: 1
--
ERROR: Ordinals are not allowed in MATCH_RECOGNIZE PARTITION BY clause [at 2:16]
  PARTITION BY 1
               ^
==

# Regression test where ValidateResolvedComputedColumn*LIST* was called from
# the loop, validating the whole measure list for each measure, instead of
# individually. Trees like subqueries under those measures could hit column ID
# uniqueness checks.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES min((select Key from KeyValue)) AS m1, max((select Key from KeyValue)) AS m2
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.m1#6 AS m1 [INT64]
| +-$match_recognize.m2#10 AS m2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[m1#6, m2#10]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[m1#6, m2#10]
        +-expr_list=
        | +-m1#6 := ColumnRef(type=INT64, column=$aggregate.$agg1#5)
        | +-m2#10 := ColumnRef(type=INT64, column=$aggregate.$agg2#9)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#5, $agg2#9]
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#5 :=
                  | +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                  |   +-SubqueryExpr
                  |     +-type=INT64
                  |     +-subquery_type=SCALAR
                  |     +-subquery=
                  |       +-ProjectScan
                  |         +-column_list=[KeyValue.Key#3]
                  |         +-input_scan=
                  |           +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
                  +-$agg2#9 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-SubqueryExpr
                        +-type=INT64
                        +-subquery_type=SCALAR
                        +-subquery=
                          +-ProjectScan
                            +-column_list=[KeyValue.Key#7]
                            +-input_scan=
                              +-TableScan(column_list=[KeyValue.Key#7], table=KeyValue, column_index_list=[0])

[UNPARSED_SQL]
SELECT
  matchrecognizescan_7.a_3 AS m1,
  matchrecognizescan_7.a_5 AS m2
FROM
  (
    SELECT
      KeyValue.Value AS a_1
    FROM
      KeyValue
  ) AS keyvalue_2 MATCH_RECOGNIZE(
    ORDER BY keyvalue_2.a_1
    MEASURES
      MIN((
          SELECT
            KeyValue.Key AS a_4
          FROM
            KeyValue
        )) AS a_3,
      MAX((
          SELECT
            KeyValue.Key AS a_6
          FROM
            KeyValue
        )) AS a_5
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_2.a_1)) < 10
  )
  AS matchrecognizescan_7;
==

# Repeated partition column
select key from KeyValue MATCH_RECOGNIZE(
  PARTITION BY key, key
  ORDER BY value
  MEASURES min(value) AS m
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Column name key is ambiguous [at 1:8]
select key from KeyValue MATCH_RECOGNIZE(
       ^
==

# ORDER BY in aggregate function call
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES ARRAY_AGG(value ORDER BY value) AS m
  PATTERN ( A A )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=ARRAY<STRING>, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:array_agg(STRING) -> ARRAY<STRING>)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                      +-order_by_item_list=
                        +-OrderByItem
                          +-column_ref=
                            +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_4.a_3 AS m
FROM
  (
    SELECT
      KeyValue.Value AS a_1
    FROM
      KeyValue
  ) AS keyvalue_2 MATCH_RECOGNIZE(
    ORDER BY keyvalue_2.a_1
    MEASURES
      ARRAY_AGG(keyvalue_2.a_1
        ORDER BY keyvalue_2.a_1) AS a_3
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_2.a_1)) < 10
  )
  AS matchrecognizescan_4;
==

[language_features=V_1_4_MATCH_RECOGNIZE,V_1_1_WITH_ON_SUBQUERY]
# DML column in partition by
DELETE FROM KeyValue WHERE
  (
    WITH t AS (SELECT 1 AS x, 2 AS y)
    select Key + m from t MATCH_RECOGNIZE(
      PARTITION BY Key            # reference a DML column
      ORDER BY y
      MEASURES min(y) AS m
      PATTERN ( a a )
      DEFINE
        A AS y < 10
    )
  ) > 0
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-column_access_list=READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    +-SubqueryExpr
    | +-type=INT64
    | +-subquery_type=SCALAR
    | +-parameter_list=
    | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | +-subquery=
    |   +-WithScan
    |     +-column_list=[$expr_subquery.$col1#10]
    |     +-with_entry_list=
    |     | +-WithEntry
    |     |   +-with_query_name="t"
    |     |   +-with_subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=t.[x#3, y#4]
    |     |       +-expr_list=
    |     |       | +-x#3 := Literal(type=INT64, value=1)
    |     |       | +-y#4 := Literal(type=INT64, value=2)
    |     |       +-input_scan=
    |     |         +-SingleRowScan
    |     +-query=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#10]
    |         +-expr_list=
    |         | +-$col1#10 :=
    |         |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |     +-ColumnRef(type=INT64, column=$partitionby.Key#7)
    |         |     +-ColumnRef(type=INT64, column=$match_recognize.m#9)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$partitionby.Key#7, $match_recognize.m#9]
    |             +-expr_list=
    |             | +-m#9 := ColumnRef(type=INT64, column=$aggregate.$agg1#8)
    |             +-input_scan=
    |               +-MatchRecognizeScan
    |                 +-column_list=[$partitionby.Key#7, $aggregate.$agg1#8]
    |                 +-input_scan=
    |                 | +-ProjectScan
    |                 |   +-column_list=[t.x#5, t.y#6, $partitionby.Key#7]
    |                 |   +-expr_list=
    |                 |   | +-Key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |                 |   +-input_scan=
    |                 |     +-WithRefScan(column_list=t.[x#5, y#6], with_query_name="t")
    |                 +-partition_by=
    |                 | +-WindowPartitioning
    |                 |   +-partition_by_list=
    |                 |     +-ColumnRef(type=INT64, column=$partitionby.Key#7)
    |                 +-order_by=
    |                 | +-WindowOrdering
    |                 |   +-order_by_item_list=
    |                 |     +-OrderByItem
    |                 |       +-column_ref=
    |                 |         +-ColumnRef(type=INT64, column=t.y#6)
    |                 +-pattern_variable_definition_list=
    |                 | +-MatchRecognizeVariableDefinition
    |                 |   +-name="A"
    |                 |   +-predicate=
    |                 |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |                 |       +-ColumnRef(type=INT64, column=t.y#6)
    |                 |       +-Literal(type=INT64, value=10)
    |                 +-pattern=
    |                 | +-MatchRecognizePatternOperation
    |                 |   +-op_type=CONCAT
    |                 |   +-operand_list=
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 +-after_match_skip_mode=END_OF_MATCH
    |                 +-measure_group_list=
    |                   +-MeasureGroup
    |                     +-aggregate_list=
    |                       +-$agg1#8 :=
    |                         +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
    |                           +-ColumnRef(type=INT64, column=t.y#6)
    +-Literal(type=INT64, value=0)

[UNPARSED_SQL]
DELETE KeyValue AS keyvalue_1
WHERE
  (WITH
      t AS (
        SELECT
          1 AS a_2,
          2 AS a_3
      )
    SELECT
      (projectscan_10.a_5) + (projectscan_10.a_9) AS a_11
    FROM
      (
        SELECT
          matchrecognizescan_8.a_5 AS a_5,
          matchrecognizescan_8.a_7 AS a_9
        FROM
          (
            SELECT
              withrefscan_4.a_2 AS a_2,
              withrefscan_4.a_3 AS a_3,
              keyvalue_1.Key AS a_5
            FROM
              t AS withrefscan_4
          ) AS projectscan_6 MATCH_RECOGNIZE(
            PARTITION BY projectscan_6.a_5
            ORDER BY projectscan_6.a_3
            MEASURES
              MIN(projectscan_6.a_3) AS a_7
            AFTER MATCH SKIP PAST LAST ROW
            PATTERN ((A  A))
            DEFINE
              A AS(projectscan_6.a_3) < 10
          )
          AS matchrecognizescan_8
      ) AS projectscan_10
  ) > 0;
==

[language_features=V_1_4_MATCH_RECOGNIZE,V_1_1_WITH_ON_SUBQUERY]
# DML column in partition by with duplication
DELETE FROM KeyValue WHERE
  (
    WITH t AS (SELECT 1 AS x, 2 AS y)
    select Key + m from t MATCH_RECOGNIZE(
      PARTITION BY value, value            # reference a DML column
      ORDER BY y
      MEASURES min(y) AS m
      PATTERN ( a a )
      DEFINE
        A AS y < 10
    )
  ) > 0
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ,READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    +-SubqueryExpr
    | +-type=INT64
    | +-subquery_type=SCALAR
    | +-parameter_list=
    | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    | +-subquery=
    |   +-WithScan
    |     +-column_list=[$expr_subquery.$col1#11]
    |     +-with_entry_list=
    |     | +-WithEntry
    |     |   +-with_query_name="t"
    |     |   +-with_subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=t.[x#3, y#4]
    |     |       +-expr_list=
    |     |       | +-x#3 := Literal(type=INT64, value=1)
    |     |       | +-y#4 := Literal(type=INT64, value=2)
    |     |       +-input_scan=
    |     |         +-SingleRowScan
    |     +-query=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#11]
    |         +-expr_list=
    |         | +-$col1#11 :=
    |         |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |     +-ColumnRef(type=INT64, column=$match_recognize.m#10)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$partitionby.value#7, $partitionby.value#8, $match_recognize.m#10]
    |             +-expr_list=
    |             | +-m#10 := ColumnRef(type=INT64, column=$aggregate.$agg1#9)
    |             +-input_scan=
    |               +-MatchRecognizeScan
    |                 +-column_list=[$partitionby.value#7, $partitionby.value#8, $aggregate.$agg1#9]
    |                 +-input_scan=
    |                 | +-ProjectScan
    |                 |   +-column_list=[t.x#5, t.y#6, $partitionby.value#7, $partitionby.value#8]
    |                 |   +-expr_list=
    |                 |   | +-value#7 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |                 |   | +-value#8 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |                 |   +-input_scan=
    |                 |     +-WithRefScan(column_list=t.[x#5, y#6], with_query_name="t")
    |                 +-partition_by=
    |                 | +-WindowPartitioning
    |                 |   +-partition_by_list=
    |                 |     +-ColumnRef(type=STRING, column=$partitionby.value#7)
    |                 |     +-ColumnRef(type=STRING, column=$partitionby.value#8)
    |                 +-order_by=
    |                 | +-WindowOrdering
    |                 |   +-order_by_item_list=
    |                 |     +-OrderByItem
    |                 |       +-column_ref=
    |                 |         +-ColumnRef(type=INT64, column=t.y#6)
    |                 +-pattern_variable_definition_list=
    |                 | +-MatchRecognizeVariableDefinition
    |                 |   +-name="A"
    |                 |   +-predicate=
    |                 |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |                 |       +-ColumnRef(type=INT64, column=t.y#6)
    |                 |       +-Literal(type=INT64, value=10)
    |                 +-pattern=
    |                 | +-MatchRecognizePatternOperation
    |                 |   +-op_type=CONCAT
    |                 |   +-operand_list=
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 +-after_match_skip_mode=END_OF_MATCH
    |                 +-measure_group_list=
    |                   +-MeasureGroup
    |                     +-aggregate_list=
    |                       +-$agg1#9 :=
    |                         +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
    |                           +-ColumnRef(type=INT64, column=t.y#6)
    +-Literal(type=INT64, value=0)

[UNPARSED_SQL]
DELETE KeyValue AS keyvalue_1
WHERE
  (WITH
      t AS (
        SELECT
          1 AS a_2,
          2 AS a_3
      )
    SELECT
      (keyvalue_1.Key) + (projectscan_11.a_10) AS a_12
    FROM
      (
        SELECT
          matchrecognizescan_9.a_5 AS a_5,
          matchrecognizescan_9.a_6 AS a_6,
          matchrecognizescan_9.a_8 AS a_10
        FROM
          (
            SELECT
              withrefscan_4.a_2 AS a_2,
              withrefscan_4.a_3 AS a_3,
              keyvalue_1.Value AS a_5,
              keyvalue_1.Value AS a_6
            FROM
              t AS withrefscan_4
          ) AS projectscan_7 MATCH_RECOGNIZE(
            PARTITION BY projectscan_7.a_5, projectscan_7.a_6
            ORDER BY projectscan_7.a_3
            MEASURES
              MIN(projectscan_7.a_3) AS a_8
            AFTER MATCH SKIP PAST LAST ROW
            PATTERN ((A  A))
            DEFINE
              A AS(projectscan_7.a_3) < 10
          )
          AS matchrecognizescan_9
      ) AS projectscan_11
  ) > 0;
==

[language_features=V_1_4_MATCH_RECOGNIZE,V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE,V_1_1_ORDER_BY_IN_AGGREGATE,V_1_1_HAVING_IN_AGGREGATE,V_1_1_LIMIT_IN_AGGREGATE]
# Modifiers on the measure aggregations
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES array_agg(
              value
              RESPECT NULLS
              HAVING MAX fn_optional_any(value)
              ORDER BY fn_on_string(value)
              LIMIT @test_param_int64
            ) AS m
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#5 AS m [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#5]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#5]
        +-expr_list=
        | +-m#5 := ColumnRef(type=ARRAY<STRING>, column=$aggregate.$agg1#4)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#4]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Value#2, $orderby.$orderbycol1#3]
            |   +-expr_list=
            |   | +-$orderbycol1#3 :=
            |   |   +-FunctionCall(sample_functions:fn_on_string(STRING) -> BOOL)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   +-input_scan=
            |     +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#4 :=
                    +-AggregateFunctionCall(ZetaSQL:array_agg(STRING) -> ARRAY<STRING>)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                      +-null_handling_modifier=RESPECT_NULLS
                      +-having_modifier=
                      | +-AggregateHavingModifier
                      |   +-kind=MAX
                      |   +-having_expr=
                      |     +-FunctionCall(sample_functions:fn_optional_any(optional(1) STRING) -> STRING)
                      |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                      +-order_by_item_list=
                      | +-OrderByItem
                      |   +-column_ref=
                      |     +-ColumnRef(type=BOOL, column=$orderby.$orderbycol1#3)
                      +-limit=
                        +-Parameter(type=INT64, name="test_param_int64")

[UNPARSED_SQL]
SELECT
  matchrecognizescan_6.a_5 AS m
FROM
  (
    SELECT
      keyvalue_2.a_1 AS a_1,
      FN_ON_STRING(keyvalue_2.a_1) AS a_3
    FROM
      (
        SELECT
          KeyValue.Value AS a_1
        FROM
          KeyValue
      ) AS keyvalue_2
  ) AS projectscan_4 MATCH_RECOGNIZE(
    ORDER BY projectscan_4.a_1
    MEASURES
      ARRAY_AGG(projectscan_4.a_1 RESPECT NULLS
        HAVING MAX FN_OPTIONAL_ANY(projectscan_4.a_1)
        ORDER BY projectscan_4.a_3
        LIMIT @test_param_int64) AS a_5
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(projectscan_4.a_1)) < 10
  )
  AS matchrecognizescan_6;
==

# Disallows window functions in MEASURES for ONE ROW PER MATCH
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES
    min(value) OVER (PARTITION BY fn_on_string(value) ORDER BY fn_optional_any(value)) AS m2
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--

ERROR: Analytic function not allowed in MATCH_RECOGNIZE MEASURES clause [at 4:5]
    min(value) OVER (PARTITION BY fn_on_string(value) ORDER BY fn_optional_an...
    ^
==

# Allows window functions in a subquery in MEASURES
WITH t AS (SELECT 1 AS x, 2 AS y)
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES
    min(length(value)) + (SELECT max(x) OVER(ORDER BY y) FROM t) AS m
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#10 AS m [INT64]
+-query=
  +-WithScan
    +-column_list=[$match_recognize.m#10]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[x#1, y#2]
    |       +-expr_list=
    |       | +-x#1 := Literal(type=INT64, value=1)
    |       | +-y#2 := Literal(type=INT64, value=2)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$match_recognize.m#10]
        +-input_scan=
          +-ProjectScan
            +-column_list=[$match_recognize.m#10]
            +-expr_list=
            | +-m#10 :=
            |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
            |     +-SubqueryExpr
            |       +-type=INT64
            |       +-subquery_type=SCALAR
            |       +-subquery=
            |         +-ProjectScan
            |           +-column_list=[$analytic.$analytic1#9]
            |           +-input_scan=
            |             +-AnalyticScan
            |               +-column_list=[t.x#6, t.y#7, $analytic.$analytic1#9]
            |               +-input_scan=
            |               | +-WithRefScan(column_list=t.[x#6, y#7], with_query_name="t")
            |               +-function_group_list=
            |                 +-AnalyticFunctionGroup
            |                   +-order_by=
            |                   | +-WindowOrdering
            |                   |   +-order_by_item_list=
            |                   |     +-OrderByItem
            |                   |       +-column_ref=
            |                   |         +-ColumnRef(type=INT64, column=t.y#7)
            |                   +-analytic_function_list=
            |                     +-$analytic1#9 :=
            |                       +-AnalyticFunctionCall(ZetaSQL:max(INT64) -> INT64)
            |                         +-ColumnRef(type=INT64, column=t.x#6)
            |                         +-window_frame=
            |                           +-WindowFrame(frame_unit=RANGE)
            |                             +-start_expr=
            |                             | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
            |                             +-end_expr=
            |                               +-WindowFrameExpr(boundary_type=CURRENT ROW)
            +-input_scan=
              +-MatchRecognizeScan
                +-column_list=[$aggregate.$agg1#5]
                +-input_scan=
                | +-TableScan(column_list=[KeyValue.Value#4], table=KeyValue, column_index_list=[1])
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |         +-ColumnRef(type=STRING, column=KeyValue.Value#4)
                +-pattern_variable_definition_list=
                | +-MatchRecognizeVariableDefinition
                |   +-name="A"
                |   +-predicate=
                |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
                |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#4)
                |       +-Literal(type=INT64, value=10)
                +-pattern=
                | +-MatchRecognizePatternOperation
                |   +-op_type=CONCAT
                |   +-operand_list=
                |     +-MatchRecognizePatternVariableRef(name="A")
                |     +-MatchRecognizePatternVariableRef(name="A")
                +-after_match_skip_mode=END_OF_MATCH
                +-measure_group_list=
                  +-MeasureGroup
                    +-aggregate_list=
                      +-$agg1#5 :=
                        +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                          +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                            +-ColumnRef(type=STRING, column=KeyValue.Value#4)

[UNPARSED_SQL]
WITH
  t AS (
    SELECT
      1 AS a_1,
      2 AS a_2
  )
SELECT
  (matchrecognizescan_6.a_5) + (
    SELECT
      analyticscan_10.a_9 AS a_9
    FROM
      (
        SELECT
          withrefscan_8.a_1 AS a_1,
          withrefscan_8.a_2 AS a_2,
          MAX(withrefscan_8.a_1) OVER (
            ORDER BY withrefscan_8.a_2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a_9
        FROM
          t AS withrefscan_8
      ) AS analyticscan_10
  ) AS m
FROM
  (
    SELECT
      KeyValue.Value AS a_3
    FROM
      KeyValue
  ) AS keyvalue_4 MATCH_RECOGNIZE(
    ORDER BY keyvalue_4.a_3
    MEASURES
      MIN(LENGTH(keyvalue_4.a_3)) AS a_5
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_4.a_3)) < 10
  )
  AS matchrecognizescan_6;
==

# Trivial measures with no aggregations. No aggregations in the measures_list,
# so SqlBuilder needs to add a dummy measure to generate a valid query.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY Key
  MEASURES 1 AS one
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.one#3 AS one [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.one#3]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.one#3]
        +-expr_list=
        | +-one#3 := Literal(type=INT64, value=1)
        +-input_scan=
          +-MatchRecognizeScan
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH

[UNPARSED_SQL]
SELECT
  1 AS one
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      1 AS m_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
  )
  AS matchrecognizescan_5;
==

# Correct error when ordinals are out of range
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  PARTITION BY Key
  ORDER BY value
  MEASURES 1 AS m
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
ORDER BY 1, 2, 3
--
ERROR: ORDER BY is out of SELECT column number range: 3 [at 9:16]
ORDER BY 1, 2, 3
               ^
==

# Partition by a correlated column, with duplication
# Note that x is correlated, and is duplicated, and there's a measure with the
# same name.
WITH t AS (SELECT 1 AS x, 2 AS y)
SELECT * FROM t AS outer_t
WHERE
  x < (SELECT y+length(m)
        FROM KeyValue MATCH_RECOGNIZE(
          PARTITION BY outer_t.y, x, x
          ORDER BY value
          MEASURES min(value) AS m, max(value) AS x
          PATTERN ( a a )
          DEFINE
            A AS length(value) < 10
        )
      )
--
QueryStmt
+-output_column_list=
| +-t.x#3 AS x [INT64]
| +-t.y#4 AS y [INT64]
+-query=
  +-WithScan
    +-column_list=t.[x#3, y#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[x#1, y#2]
    |       +-expr_list=
    |       | +-x#1 := Literal(type=INT64, value=1)
    |       | +-y#2 := Literal(type=INT64, value=2)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=t.[x#3, y#4]
        +-input_scan=
          +-FilterScan
            +-column_list=t.[x#3, y#4]
            +-input_scan=
            | +-WithRefScan(column_list=t.[x#3, y#4], with_query_name="t")
            +-filter_expr=
              +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
                +-ColumnRef(type=INT64, column=t.x#3)
                +-SubqueryExpr
                  +-type=INT64
                  +-subquery_type=SCALAR
                  +-parameter_list=
                  | +-ColumnRef(type=INT64, column=t.x#3)
                  | +-ColumnRef(type=INT64, column=t.y#4)
                  +-subquery=
                    +-ProjectScan
                      +-column_list=[$expr_subquery.$col1#14]
                      +-expr_list=
                      | +-$col1#14 :=
                      |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                      |     +-ColumnRef(type=INT64, column=$partitionby.y#7)
                      |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                      |       +-ColumnRef(type=STRING, column=$match_recognize.m#11)
                      +-input_scan=
                        +-ProjectScan
                          +-column_list=[$partitionby.y#7, $partitionby.x#8, $partitionby.x#9, $match_recognize.m#11, $match_recognize.x#13]
                          +-expr_list=
                          | +-m#11 := ColumnRef(type=STRING, column=$aggregate.$agg1#10)
                          | +-x#13 := ColumnRef(type=STRING, column=$aggregate.$agg2#12)
                          +-input_scan=
                            +-MatchRecognizeScan
                              +-column_list=[$partitionby.y#7, $partitionby.x#8, $partitionby.x#9, $aggregate.$agg1#10, $aggregate.$agg2#12]
                              +-input_scan=
                              | +-ProjectScan
                              |   +-column_list=[KeyValue.Value#6, $partitionby.y#7, $partitionby.x#8, $partitionby.x#9]
                              |   +-expr_list=
                              |   | +-y#7 := ColumnRef(type=INT64, column=t.y#4, is_correlated=TRUE)
                              |   | +-x#8 := ColumnRef(type=INT64, column=t.x#3, is_correlated=TRUE)
                              |   | +-x#9 := ColumnRef(type=INT64, column=t.x#3, is_correlated=TRUE)
                              |   +-input_scan=
                              |     +-TableScan(column_list=[KeyValue.Value#6], table=KeyValue, column_index_list=[1])
                              +-partition_by=
                              | +-WindowPartitioning
                              |   +-partition_by_list=
                              |     +-ColumnRef(type=INT64, column=$partitionby.y#7)
                              |     +-ColumnRef(type=INT64, column=$partitionby.x#8)
                              |     +-ColumnRef(type=INT64, column=$partitionby.x#9)
                              +-order_by=
                              | +-WindowOrdering
                              |   +-order_by_item_list=
                              |     +-OrderByItem
                              |       +-column_ref=
                              |         +-ColumnRef(type=STRING, column=KeyValue.Value#6)
                              +-pattern_variable_definition_list=
                              | +-MatchRecognizeVariableDefinition
                              |   +-name="A"
                              |   +-predicate=
                              |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
                              |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                              |       | +-ColumnRef(type=STRING, column=KeyValue.Value#6)
                              |       +-Literal(type=INT64, value=10)
                              +-pattern=
                              | +-MatchRecognizePatternOperation
                              |   +-op_type=CONCAT
                              |   +-operand_list=
                              |     +-MatchRecognizePatternVariableRef(name="A")
                              |     +-MatchRecognizePatternVariableRef(name="A")
                              +-after_match_skip_mode=END_OF_MATCH
                              +-measure_group_list=
                                +-MeasureGroup
                                  +-aggregate_list=
                                    +-$agg1#10 :=
                                    | +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                                    |   +-ColumnRef(type=STRING, column=KeyValue.Value#6)
                                    +-$agg2#12 :=
                                      +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
                                        +-ColumnRef(type=STRING, column=KeyValue.Value#6)

[UNPARSED_SQL]
WITH
  t AS (
    SELECT
      1 AS a_1,
      2 AS a_2
  )
SELECT
  withrefscan_3.a_1 AS x,
  withrefscan_3.a_2 AS y
FROM
  t AS withrefscan_3
WHERE
  (withrefscan_3.a_1) < (
    SELECT
      (projectscan_15.a_6) + (LENGTH(projectscan_15.a_13)) AS a_16
    FROM
      (
        SELECT
          matchrecognizescan_12.a_6 AS a_6,
          matchrecognizescan_12.a_7 AS a_7,
          matchrecognizescan_12.a_8 AS a_8,
          matchrecognizescan_12.a_10 AS a_13,
          matchrecognizescan_12.a_11 AS a_14
        FROM
          (
            SELECT
              keyvalue_5.a_4 AS a_4,
              withrefscan_3.a_2 AS a_6,
              withrefscan_3.a_1 AS a_7,
              withrefscan_3.a_1 AS a_8
            FROM
              (
                SELECT
                  KeyValue.Value AS a_4
                FROM
                  KeyValue
              ) AS keyvalue_5
          ) AS projectscan_9 MATCH_RECOGNIZE(
            PARTITION BY projectscan_9.a_6, projectscan_9.a_7, projectscan_9.a_8
            ORDER BY projectscan_9.a_4
            MEASURES
              MIN(projectscan_9.a_4) AS a_10,
              MAX(projectscan_9.a_4) AS a_11
            AFTER MATCH SKIP PAST LAST ROW
            PATTERN ((A  A))
            DEFINE
              A AS(LENGTH(projectscan_9.a_4)) < 10
          )
          AS matchrecognizescan_12
      ) AS projectscan_15
  );
==

# Partition by duplicate columns
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  PARTITION BY Key, Key, Key+1, Key+1
  ORDER BY value
  MEASURES min(value) AS Key, max(value) AS Key
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$partitionby.Key#3 AS Key [INT64]
| +-$partitionby.Key#4 AS Key [INT64]
| +-$partitionby.$partitionbycol3#5 AS `$partition_by_col3` [INT64]
| +-$partitionby.$partitionbycol4#6 AS `$partition_by_col4` [INT64]
| +-$match_recognize.Key#8 AS Key [STRING]
| +-$match_recognize.Key#10 AS Key [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$partitionby.Key#3, $partitionby.Key#4, $partitionby.$partitionbycol3#5, $partitionby.$partitionbycol4#6, $match_recognize.Key#8, $match_recognize.Key#10]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$partitionby.Key#3, $partitionby.Key#4, $partitionby.$partitionbycol3#5, $partitionby.$partitionbycol4#6, $match_recognize.Key#8, $match_recognize.Key#10]
        +-expr_list=
        | +-Key#8 := ColumnRef(type=STRING, column=$aggregate.$agg1#7)
        | +-Key#10 := ColumnRef(type=STRING, column=$aggregate.$agg2#9)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$partitionby.Key#3, $partitionby.Key#4, $partitionby.$partitionbycol3#5, $partitionby.$partitionbycol4#6, $aggregate.$agg1#7, $aggregate.$agg2#9]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.Key#3, $partitionby.Key#4, $partitionby.$partitionbycol3#5, $partitionby.$partitionbycol4#6]
            |   +-expr_list=
            |   | +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | +-Key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | +-$partitionbycol3#5 :=
            |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |   | |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | |   +-Literal(type=INT64, value=1)
            |   | +-$partitionbycol4#6 :=
            |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$partitionby.Key#3)
            |     +-ColumnRef(type=INT64, column=$partitionby.Key#4)
            |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol3#5)
            |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol4#6)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#7 :=
                  | +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                  |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-$agg2#9 :=
                    +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
                      +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_11.a_4 AS Key,
  matchrecognizescan_11.a_5 AS Key,
  matchrecognizescan_11.a_6 AS a_6,
  matchrecognizescan_11.a_7 AS a_7,
  matchrecognizescan_11.a_9 AS Key,
  matchrecognizescan_11.a_10 AS Key
FROM
  (
    SELECT
      keyvalue_3.a_1 AS a_1,
      keyvalue_3.a_2 AS a_2,
      keyvalue_3.a_1 AS a_4,
      keyvalue_3.a_1 AS a_5,
      (keyvalue_3.a_1) + 1 AS a_6,
      (keyvalue_3.a_1) + 1 AS a_7
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  ) AS projectscan_8 MATCH_RECOGNIZE(
    PARTITION BY projectscan_8.a_4, projectscan_8.a_5, projectscan_8.a_6, projectscan_8.a_7
    ORDER BY projectscan_8.a_2
    MEASURES
      MIN(projectscan_8.a_2) AS a_9,
      MAX(projectscan_8.a_2) AS a_10
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(projectscan_8.a_2)) < 10
  )
  AS matchrecognizescan_11;
==

# Correct name resolution on partitioning columns
SELECT * FROM KeyValue MATCH_RECOGNIZE(
    PARTITION BY Key
    ORDER BY value
    MEASURES max(length(value)) + Key AS m
    PATTERN ( a )
    DEFINE
      a AS true
  )
--
QueryStmt
+-output_column_list=
| +-$partitionby.Key#3 AS Key [INT64]
| +-$match_recognize.m#5 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$partitionby.Key#3, $match_recognize.m#5]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$partitionby.Key#3, $match_recognize.m#5]
        +-expr_list=
        | +-m#5 :=
        |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
        |     +-ColumnRef(type=INT64, column=$partitionby.Key#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$partitionby.Key#3, $aggregate.$agg1#4]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.Key#3]
            |   +-expr_list=
            |   | +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$partitionby.Key#3)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="a"
            |   +-predicate=
            |     +-Literal(type=BOOL, value=true)
            +-pattern=
            | +-MatchRecognizePatternVariableRef(name="a")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#4 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_7.a_4 AS Key,
  (matchrecognizescan_7.a_6) + (matchrecognizescan_7.a_4) AS m
FROM
  (
    SELECT
      keyvalue_3.a_1 AS a_1,
      keyvalue_3.a_2 AS a_2,
      keyvalue_3.a_1 AS a_4
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  ) AS projectscan_5 MATCH_RECOGNIZE(
    PARTITION BY projectscan_5.a_4
    ORDER BY projectscan_5.a_2
    MEASURES
      MAX(LENGTH(projectscan_5.a_2)) AS a_6
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (a)
    DEFINE
      a AS true
  )
  AS matchrecognizescan_7;
==

# AFTER MATCH SKIP TO PAST LAST ROW
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES max(length(value)) AS m
  {{|AFTER MATCH SKIP PAST LAST ROW|AFTER MATCH SKIP TO NEXT ROW}}
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
)
--
ALTERNATION GROUPS:
    <empty>
    AFTER MATCH SKIP PAST LAST ROW
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MAX(LENGTH(keyvalue_3.a_2)) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
  )
  AS matchrecognizescan_5;
--
ALTERNATION GROUP: AFTER MATCH SKIP TO NEXT ROW
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=NEXT_ROW
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MAX(LENGTH(keyvalue_3.a_2)) AS a_4
    AFTER MATCH SKIP TO NEXT ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
  )
  AS matchrecognizescan_5;
==

# With the use_longest_match option
[allow_undeclared_parameters]
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS ({{use_LonGeST_match|`use_LonGeST_match`}} = {{true|false|@test_param_bool|@p}})
)
--
ALTERNATION GROUPS:
    use_LonGeST_match,true
    `use_LonGeST_match`,true
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-option_list=
            | +-use_LonGeST_match := Literal(type=BOOL, value=true)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MAX(LENGTH(keyvalue_3.a_2)) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
    OPTIONS(use_LonGeST_match = true)
  )
  AS matchrecognizescan_5;
[UNDECLARED_PARAMETERS]
--
ALTERNATION GROUPS:
    use_LonGeST_match,false
    `use_LonGeST_match`,false
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-option_list=
            | +-use_LonGeST_match := Literal(type=BOOL, value=false)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MAX(LENGTH(keyvalue_3.a_2)) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
    OPTIONS(use_LonGeST_match = false)
  )
  AS matchrecognizescan_5;
[UNDECLARED_PARAMETERS]
--
ALTERNATION GROUPS:
    use_LonGeST_match,@test_param_bool
    `use_LonGeST_match`,@test_param_bool
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-option_list=
            | +-use_LonGeST_match := Parameter(type=BOOL, name="test_param_bool")
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MAX(LENGTH(keyvalue_3.a_2)) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
    OPTIONS(use_LonGeST_match = @test_param_bool)
  )
  AS matchrecognizescan_5;
[UNDECLARED_PARAMETERS]
--
ALTERNATION GROUP: use_LonGeST_match,@p
--
ERROR: MATCH_RECOGNIZE option `use_LonGeST_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (use_LonGeST_match = @p)
          ^
--
ALTERNATION GROUP: `use_LonGeST_match`,@p
--
ERROR: MATCH_RECOGNIZE option `use_LonGeST_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (`use_LonGeST_match` = @p)
          ^
==

# Empty options list is a NOOP
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS ()
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MAX(LENGTH(keyvalue_3.a_2)) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((A  A))
    DEFINE
      A AS(LENGTH(keyvalue_3.a_2)) < 10
  )
  AS matchrecognizescan_5;
==

# Duplicate option
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS (use_longest_match = true, use_longest_match = true)
)
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` cannot be specified multiple times [at 7:11]
  OPTIONS (use_longest_match = true, use_longest_match = true)
          ^
==

# Invalid values
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS (use_longest_match = {{false AND true|NULL|UNKNOWN|CAST(NULL AS BOOL)|CAST(UNKNOWN AS BOOL)|"foo"|1+1|true IS NOT NULL|@test_param_int64}})
)
--
ALTERNATION GROUP: false AND true
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean literal or parameter [at 7:11]
  OPTIONS (use_longest_match = false AND true)
          ^
--
ALTERNATION GROUP: NULL
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (use_longest_match = NULL)
          ^
--
ALTERNATION GROUP: UNKNOWN
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found STRING [at 7:11]
  OPTIONS (use_longest_match = UNKNOWN)
          ^
--
ALTERNATION GROUP: CAST(NULL AS BOOL)
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` cannot be NULL [at 7:11]
  OPTIONS (use_longest_match = CAST(NULL AS BOOL))
          ^
--
ALTERNATION GROUP: CAST(UNKNOWN AS BOOL)
--
ERROR: Unrecognized name: UNKNOWN [at 7:37]
  OPTIONS (use_longest_match = CAST(UNKNOWN AS BOOL))
                                    ^
--
ALTERNATION GROUP: "foo"
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found STRING [at 7:11]
  OPTIONS (use_longest_match = "foo")
          ^
--
ALTERNATION GROUP: 1+1
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (use_longest_match = 1+1)
          ^
--
ALTERNATION GROUP: true IS NOT NULL
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean literal or parameter [at 7:11]
  OPTIONS (use_longest_match = true IS NOT NULL)
          ^
--
ALTERNATION GROUP: @test_param_int64
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (use_longest_match = @test_param_int64)
          ^
==

# Invalid option names & qualifiers
[allow_undeclared_parameters]
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS ({{@test_param_string|@p|?|blah|x.use_longest_match}} = true)
)
--
ALTERNATION GROUP: @test_param_string
--
ERROR: Syntax error: Unexpected "@" [at 7:12]
  OPTIONS (@test_param_string = true)
           ^
--
ALTERNATION GROUP: @p
--
ERROR: Syntax error: Unexpected "@" [at 7:12]
  OPTIONS (@p = true)
           ^
--
ALTERNATION GROUP: ?
--
ERROR: Syntax error: Unexpected "?" [at 7:12]
  OPTIONS (? = true)
           ^
--
ALTERNATION GROUP: blah
--
ERROR: Unrecognized MATCH_RECOGNIZE option `blah` [at 7:11]
  OPTIONS (blah = true)
          ^
--
ALTERNATION GROUP: x.use_longest_match
--
ERROR: Syntax error: Expected "=" but got "." [at 7:13]
  OPTIONS (x.use_longest_match = true)
            ^
==

# Anchors, which can be quantified if parenthesized
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (`^` ^ (^`^`)+ | ($)+? $ `$`)
  DEFINE
    `^` AS length(value) < 10,
    `$` AS length(value) > 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#4 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#4]
        +-expr_list=
        | +-m#4 := ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="^"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="$"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=ALTERNATE
            |   +-operand_list=
            |     +-MatchRecognizePatternOperation
            |     | +-op_type=CONCAT
            |     | +-operand_list=
            |     |   +-MatchRecognizePatternVariableRef(name="^")
            |     |   +-MatchRecognizePatternAnchor(mode=START)
            |     |   +-MatchRecognizePatternQuantification
            |     |     +-operand=
            |     |     | +-MatchRecognizePatternOperation
            |     |     |   +-op_type=CONCAT
            |     |     |   +-operand_list=
            |     |     |     +-MatchRecognizePatternAnchor(mode=START)
            |     |     |     +-MatchRecognizePatternVariableRef(name="^")
            |     |     +-lower_bound=
            |     |     | +-Literal(type=INT64, value=1)
            |     |     +-is_reluctant=FALSE
            |     +-MatchRecognizePatternOperation
            |       +-op_type=CONCAT
            |       +-operand_list=
            |         +-MatchRecognizePatternQuantification
            |         | +-operand=
            |         | | +-MatchRecognizePatternAnchor(mode=END)
            |         | +-lower_bound=
            |         | | +-Literal(type=INT64, value=1)
            |         | +-is_reluctant=TRUE
            |         +-MatchRecognizePatternAnchor(mode=END)
            |         +-MatchRecognizePatternVariableRef(name="$")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#3 :=
                    +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                        +-ColumnRef(type=STRING, column=KeyValue.Value#2)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_5.a_4 AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MAX(LENGTH(keyvalue_3.a_2)) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (((`^`  (^)  (((^)  `^`) { 1, })) |((($) { 1, } ?)  ($)  `$`)))
    DEFINE
      `^` AS(LENGTH(keyvalue_3.a_2)) < 10,
      `$` AS(LENGTH(keyvalue_3.a_2)) > 10
  )
  AS matchrecognizescan_5;
==

# Inside a function definition. Regression test for b/374847219.
# Note that this is a UDF, not a TVF, so the SELECT is a subquery.
CREATE TEMP FUNCTION tvf(fn_arg INT64) RETURNS INT64 AS (
  (
    SELECT max(m) FROM KeyValue t MATCH_RECOGNIZE(
      PARTITION BY fn_arg
      ORDER BY length(value) / fn_arg
      MEASURES
        min(length(value) + key + fn_arg) - fn_arg AS m
      PATTERN (a)
      DEFINE
        A AS length(value) < 10
    )
  )
)
--
CreateFunctionStmt
+-name_path=tvf
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[fn_arg]
+-signature=(INT64 fn_arg) -> INT64
+-language="SQL"
+-code="(\n    SELECT max(m) FROM KeyValue t MATCH_RECOGNIZE(\n      PARTITION BY fn_arg\n      ORDER BY length(value) / fn_arg\n      MEASURES\n        min(length(value) + key + fn_arg) - fn_arg AS m\n      PATTERN (a)\n      DEFINE\n        A AS length(value) < 10\n    )\n  )"
+-function_expression=
  +-SubqueryExpr
    +-type=INT64
    +-subquery_type=SCALAR
    +-subquery=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$aggregate.$agg1#7]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[$partitionby.fn_arg#3, $match_recognize.m#6]
            |   +-expr_list=
            |   | +-m#6 :=
            |   |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
            |   |     +-ArgumentRef(type=INT64, name="fn_arg")
            |   +-input_scan=
            |     +-MatchRecognizeScan
            |       +-column_list=[$partitionby.fn_arg#3, $aggregate.$agg1#5]
            |       +-input_scan=
            |       | +-ProjectScan
            |       |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.fn_arg#3, $orderby.$orderbycol1#4]
            |       |   +-expr_list=
            |       |   | +-fn_arg#3 := ArgumentRef(type=INT64, name="fn_arg")
            |       |   | +-$orderbycol1#4 :=
            |       |   |   +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
            |       |   |     +-Cast(INT64 -> DOUBLE)
            |       |   |     | +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       |   |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       |   |     +-Cast(INT64 -> DOUBLE)
            |       |   |       +-ArgumentRef(type=INT64, name="fn_arg")
            |       |   +-input_scan=
            |       |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t")
            |       +-partition_by=
            |       | +-WindowPartitioning
            |       |   +-partition_by_list=
            |       |     +-ColumnRef(type=INT64, column=$partitionby.fn_arg#3)
            |       +-order_by=
            |       | +-WindowOrdering
            |       |   +-order_by_item_list=
            |       |     +-OrderByItem
            |       |       +-column_ref=
            |       |         +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#4)
            |       +-pattern_variable_definition_list=
            |       | +-MatchRecognizeVariableDefinition
            |       |   +-name="A"
            |       |   +-predicate=
            |       |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |       |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       |       +-Literal(type=INT64, value=10)
            |       +-pattern=
            |       | +-MatchRecognizePatternVariableRef(name="A")
            |       +-after_match_skip_mode=END_OF_MATCH
            |       +-measure_group_list=
            |         +-MeasureGroup
            |           +-aggregate_list=
            |             +-$agg1#5 :=
            |               +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
            |                 +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |                   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |                   | +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |                   | | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |                   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |                   +-ColumnRef(type=INT64, column=$partitionby.fn_arg#3)
            +-aggregate_list=
              +-$agg1#7 :=
                +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=$match_recognize.m#6)

[UNPARSED_SQL]
CREATE TEMP FUNCTION tvf(fn_arg INT64)
RETURNS INT64 AS (
  (
    SELECT
      MAX(projectscan_10.a_9) AS a_11
    FROM
      (
        SELECT
          matchrecognizescan_8.a_4 AS a_4,
          (matchrecognizescan_8.a_7) - fn_arg AS a_9
        FROM
          (
            SELECT
              keyvalue_3.a_1 AS a_1,
              keyvalue_3.a_2 AS a_2,
              fn_arg AS a_4,
              CAST(LENGTH(keyvalue_3.a_2) AS DOUBLE) / CAST(fn_arg AS DOUBLE) AS a_5
            FROM
              (
                SELECT
                  KeyValue.Key AS a_1,
                  KeyValue.Value AS a_2
                FROM
                  KeyValue
              ) AS keyvalue_3
          ) AS projectscan_6 MATCH_RECOGNIZE(
            PARTITION BY projectscan_6.a_4
            ORDER BY projectscan_6.a_5
            MEASURES
              MIN(((LENGTH(projectscan_6.a_2)) + (projectscan_6.a_1)) + (projectscan_6.a_4)) AS a_7
            AFTER MATCH SKIP PAST LAST ROW
            PATTERN (A)
            DEFINE
              A AS(LENGTH(projectscan_6.a_2)) < 10
          )
          AS matchrecognizescan_8
      ) AS projectscan_10
  )
);
==

# Grouping constants, catalog constants, correlated references, etc are OK since
# they're the same for all rows.
[language_features=V_1_4_MATCH_RECOGNIZE,TABLE_VALUED_FUNCTIONS,NAMED_ARGUMENTS,V_1_1_WITH_ON_SUBQUERY,V_1_3_INLINE_LAMBDA_ARGUMENT]
CREATE TEMP FUNCTION tvf(fn_arg INT64) RETURNS ARRAY<INT64> AS (
  (WITH outer_tbl AS (SELECT [1, 2] AS arr, 1 AS a)
   SELECT
      ARRAY_TRANSFORM([1, 2], lambda_arg ->
       (SELECT max(m) from KeyValue t MATCH_RECOGNIZE(
        ORDER BY length(value)
        MEASURES
          min(length(a.value) + lambda_arg + outer_tbl.a + fn_arg + TestConstantInt64) AS m
        PATTERN (a)
        DEFINE
          A AS length(value) < 10
       )
      )
     )
  FROM outer_tbl
  )
)
--
CreateFunctionStmt
+-name_path=tvf
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=ARRAY<INT64>
+-argument_name_list=[fn_arg]
+-signature=(INT64 fn_arg) -> ARRAY<INT64>
+-language="SQL"
+-code="(WITH outer_tbl AS (SELECT [1, 2] AS arr, 1 AS a)\n   SELECT\n      ARRAY_TRANSFORM([1, 2], lambda_arg ->\n       (SELECT max(m) from KeyValue t MATCH_RECOGNIZE(\n        ORDER BY length(value)\n        MEASURES\n          min(length(a.value) + lambda_arg + outer_tbl.a + fn_arg + TestConstantInt64) AS m\n        PATTERN (a)\n        DEFINE\n          A AS length(value) < 10\n       )\n      )\n     )\n  FROM outer_tbl\n  )"
+-function_expression=
  +-SubqueryExpr
    +-type=ARRAY<INT64>
    +-subquery_type=SCALAR
    +-subquery=
      +-WithScan
        +-column_list=[$expr_subquery.$col1#12]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="outer_tbl"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=outer_tbl.[arr#1, a#2]
        |       +-expr_list=
        |       | +-arr#1 := Literal(type=ARRAY<INT64>, value=[1, 2])
        |       | +-a#2 := Literal(type=INT64, value=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[$expr_subquery.$col1#12]
            +-expr_list=
            | +-$col1#12 :=
            |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<INT64> array_to_transform, FUNCTION<INT64->INT64> transformation) -> ARRAY<INT64>)
            |     +-FunctionArgument
            |     | +-expr=
            |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2])
            |     +-FunctionArgument
            |       +-inline_lambda=
            |         +-InlineLambda
            |           +-argument_list=[$lambda_arg.lambda_arg#5]
            |           +-parameter_list=
            |           | +-ColumnRef(type=INT64, column=outer_tbl.a#4)
            |           +-body=
            |             +-SubqueryExpr
            |               +-type=INT64
            |               +-subquery_type=SCALAR
            |               +-parameter_list=
            |               | +-ColumnRef(type=INT64, column=outer_tbl.a#4, is_correlated=TRUE)
            |               | +-ColumnRef(type=INT64, column=$lambda_arg.lambda_arg#5)
            |               +-subquery=
            |                 +-ProjectScan
            |                   +-column_list=[$aggregate.$agg1#11]
            |                   +-input_scan=
            |                     +-AggregateScan
            |                       +-column_list=[$aggregate.$agg1#11]
            |                       +-input_scan=
            |                       | +-ProjectScan
            |                       |   +-column_list=[$match_recognize.m#10]
            |                       |   +-expr_list=
            |                       |   | +-m#10 := ColumnRef(type=INT64, column=$aggregate.$agg1#9)
            |                       |   +-input_scan=
            |                       |     +-MatchRecognizeScan
            |                       |       +-column_list=[$aggregate.$agg1#9]
            |                       |       +-input_scan=
            |                       |       | +-ProjectScan
            |                       |       |   +-column_list=[KeyValue.Value#7, $orderby.$orderbycol1#8]
            |                       |       |   +-expr_list=
            |                       |       |   | +-$orderbycol1#8 :=
            |                       |       |   |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |                       |       |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#7)
            |                       |       |   +-input_scan=
            |                       |       |     +-TableScan(column_list=[KeyValue.Value#7], table=KeyValue, column_index_list=[1], alias="t")
            |                       |       +-order_by=
            |                       |       | +-WindowOrdering
            |                       |       |   +-order_by_item_list=
            |                       |       |     +-OrderByItem
            |                       |       |       +-column_ref=
            |                       |       |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#8)
            |                       |       +-pattern_variable_definition_list=
            |                       |       | +-MatchRecognizeVariableDefinition
            |                       |       |   +-name="A"
            |                       |       |   +-predicate=
            |                       |       |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |                       |       |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |                       |       |       | +-ColumnRef(type=STRING, column=KeyValue.Value#7)
            |                       |       |       +-Literal(type=INT64, value=10)
            |                       |       +-pattern=
            |                       |       | +-MatchRecognizePatternVariableRef(name="A")
            |                       |       +-after_match_skip_mode=END_OF_MATCH
            |                       |       +-measure_group_list=
            |                       |         +-MeasureGroup
            |                       |           +-pattern_variable_ref=
            |                       |           | +-MatchRecognizePatternVariableRef(name="A")
            |                       |           +-aggregate_list=
            |                       |             +-$agg1#9 :=
            |                       |               +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
            |                       |                 +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |                       |                   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |                       |                   | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |                       |                   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |                       |                   | | | +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |                       |                   | | | | +-ColumnRef(type=STRING, column=KeyValue.Value#7)
            |                       |                   | | | +-ColumnRef(type=INT64, column=$lambda_arg.lambda_arg#5, is_correlated=TRUE)
            |                       |                   | | +-ColumnRef(type=INT64, column=outer_tbl.a#4, is_correlated=TRUE)
            |                       |                   | +-ArgumentRef(type=INT64, name="fn_arg")
            |                       |                   +-Constant(TestConstantInt64, type=INT64, value=1)
            |                       +-aggregate_list=
            |                         +-$agg1#11 :=
            |                           +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
            |                             +-ColumnRef(type=INT64, column=$match_recognize.m#10)
            +-input_scan=
              +-WithRefScan(column_list=outer_tbl.[arr#3, a#4], with_query_name="outer_tbl")

[UNPARSED_SQL]
CREATE TEMP FUNCTION tvf(fn_arg INT64)
RETURNS ARRAY< INT64 > AS (
  (WITH
      outer_tbl AS (
        SELECT
          ARRAY< INT64 >[1, 2] AS a_1,
          1 AS a_2
      )
    SELECT
      ARRAY_TRANSFORM(ARRAY< INT64 >[1, 2], (a_5) -> (
          SELECT
            MAX(projectscan_13.a_12) AS a_14
          FROM
            (
              SELECT
                matchrecognizescan_11.a_10 AS a_12
              FROM
                (
                  SELECT
                    keyvalue_7.a_6 AS a_6,
                    LENGTH(keyvalue_7.a_6) AS a_8
                  FROM
                    (
                      SELECT
                        KeyValue.Value AS a_6
                      FROM
                        KeyValue
                    ) AS keyvalue_7
                ) AS projectscan_9 MATCH_RECOGNIZE(
                  ORDER BY projectscan_9.a_8
                  MEASURES
                    MIN(((((LENGTH(A.a_6)) + a_5) + a_2) + fn_arg) + TestConstantInt64) AS a_10
                  AFTER MATCH SKIP PAST LAST ROW
                  PATTERN (A)
                  DEFINE
                    A AS(LENGTH(projectscan_9.a_6)) < 10
                )
                AS matchrecognizescan_11
            ) AS projectscan_13
        )) AS a_4
    FROM
      outer_tbl AS withrefscan_3
  )
);
==

SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(a.key) AS min_a_z, max(a.key) AS max_a_z, min(b.key) AS min_b_z, max(b.key) AS max_b_z,
           max(a.key - length(a.value)) AS multiple_as, max(b.key - length(b.value)) AS multiple_bs,
           avg(a.key) - avg(b.key) + avg(key) AS mixed_aggs
  PATTERN ( a* b* )
  DEFINE
    a AS length(value) < 10,
    b AS length(value) >= 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.min_a_z#4 AS min_a_z [INT64]
| +-$match_recognize.max_a_z#6 AS max_a_z [INT64]
| +-$match_recognize.min_b_z#8 AS min_b_z [INT64]
| +-$match_recognize.max_b_z#10 AS max_b_z [INT64]
| +-$match_recognize.multiple_as#12 AS multiple_as [INT64]
| +-$match_recognize.multiple_bs#14 AS multiple_bs [INT64]
| +-$match_recognize.mixed_aggs#18 AS mixed_aggs [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[min_a_z#4, max_a_z#6, min_b_z#8, max_b_z#10, multiple_as#12, multiple_bs#14, mixed_aggs#18]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[min_a_z#4, max_a_z#6, min_b_z#8, max_b_z#10, multiple_as#12, multiple_bs#14, mixed_aggs#18]
        +-expr_list=
        | +-min_a_z#4 := ColumnRef(type=INT64, column=$aggregate.$agg1#3)
        | +-max_a_z#6 := ColumnRef(type=INT64, column=$aggregate.$agg2#5)
        | +-min_b_z#8 := ColumnRef(type=INT64, column=$aggregate.$agg3#7)
        | +-max_b_z#10 := ColumnRef(type=INT64, column=$aggregate.$agg4#9)
        | +-multiple_as#12 := ColumnRef(type=INT64, column=$aggregate.$agg5#11)
        | +-multiple_bs#14 := ColumnRef(type=INT64, column=$aggregate.$agg6#13)
        | +-mixed_aggs#18 :=
        |   +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
        |     +-FunctionCall(ZetaSQL:$subtract(DOUBLE, DOUBLE) -> DOUBLE)
        |     | +-ColumnRef(type=DOUBLE, column=$aggregate.$agg7#15)
        |     | +-ColumnRef(type=DOUBLE, column=$aggregate.$agg8#16)
        |     +-ColumnRef(type=DOUBLE, column=$aggregate.$agg9#17)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg9#17, $agg3#7, $agg4#9, $agg6#13, $agg8#16, $agg1#3, $agg2#5, $agg5#11, $agg7#15]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="a"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="b"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="a")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="b")
            |       +-lower_bound=
            |       | +-Literal(type=INT64, value=0)
            |       +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
              | +-aggregate_list=
              |   +-$agg9#17 :=
              |     +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
              |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-MeasureGroup
              | +-pattern_variable_ref=
              | | +-MatchRecognizePatternVariableRef(name="b")
              | +-aggregate_list=
              |   +-$agg3#7 :=
              |   | +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-$agg4#9 :=
              |   | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-$agg6#13 :=
              |   | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
              |   |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
              |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
              |   |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              |   +-$agg8#16 :=
              |     +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
              |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-MeasureGroup
                +-pattern_variable_ref=
                | +-MatchRecognizePatternVariableRef(name="a")
                +-aggregate_list=
                  +-$agg1#3 :=
                  | +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                  |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-$agg2#5 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-$agg5#11 :=
                  | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
                  |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
                  |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-$agg7#15 :=
                    +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
                      +-ColumnRef(type=INT64, column=KeyValue.Key#1)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_13.a_9 AS min_a_z,
  matchrecognizescan_13.a_10 AS max_a_z,
  matchrecognizescan_13.a_5 AS min_b_z,
  matchrecognizescan_13.a_6 AS max_b_z,
  matchrecognizescan_13.a_11 AS multiple_as,
  matchrecognizescan_13.a_7 AS multiple_bs,
  ((matchrecognizescan_13.a_12) - (matchrecognizescan_13.a_8)) + (matchrecognizescan_13.a_4) AS mixed_aggs
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      AVG(keyvalue_3.a_1) AS a_4,
      MIN(b.a_1) AS a_5,
      MAX(b.a_1) AS a_6,
      MAX((b.a_1) - (LENGTH(b.a_2))) AS a_7,
      AVG(b.a_1) AS a_8,
      MIN(a.a_1) AS a_9,
      MAX(a.a_1) AS a_10,
      MAX((a.a_1) - (LENGTH(a.a_2))) AS a_11,
      AVG(a.a_1) AS a_12
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (((a { 0, })  (b { 0, })))
    DEFINE
      a AS(LENGTH(keyvalue_3.a_2)) < 10,
      b AS(LENGTH(keyvalue_3.a_2)) >= 10
  )
  AS matchrecognizescan_13;
==

# Subqueries in the MEASURES clause cannot see the pattern variables.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES max((SELECT max(a.value) FROM UNNEST([1,2]) AS t)) AS mx
  PATTERN (a)
  DEFINE a AS true
)
--
ERROR: Pattern variables can only be referenced in the same MATCH_RECOGNIZE clause defining them directly without subqueries [at 3:28]
  MEASURES max((SELECT max(a.value) FROM UNNEST([1,2]) AS t)) AS mx
                           ^
==

# Nested MR cannot reference a pattern var from an outer MR.
# But they can be shadowed by names in the inner MR, e.g. note the alternation
# where `a` is shadowed by the inner MR's input range variable.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES max(
              (SELECT v1 || v2 FROM KeyValue {{|a}} MATCH_RECOGNIZE(
                  ORDER BY key
                  MEASURES min({{a|a.value}}) AS v1, min(b.value) AS v2
                  PATTERN (b)
                  DEFINE b AS true
                )
              )
          ) AS mx
  PATTERN (a b)
  DEFINE a AS length(value) < 10,
         b AS length(value) >= 10
)
--
ALTERNATION GROUP: a
--
ERROR: Pattern variables can only be referenced in the same MATCH_RECOGNIZE clause defining them directly without subqueries [at 6:32]
                  MEASURES min(a) AS v1, min(b.value) AS v2
                               ^
--
ALTERNATION GROUP: a.value
--
ERROR: Pattern variables can only be referenced in the same MATCH_RECOGNIZE clause defining them directly without subqueries [at 6:32]
                  MEASURES min(a.value) AS v1, min(b.value) AS v2
                               ^
--
ALTERNATION GROUP: a,a
--
ERROR: MIN is not defined for arguments of type STRUCT<Key INT64, Value STRING> [at 6:28]
                  MEASURES min(a) AS v1, min(b.value) AS v2
                           ^
--
ALTERNATION GROUP: a,a.value
--
QueryStmt
+-output_column_list=
| +-$match_recognize.mx#11 AS mx [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.mx#11]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.mx#11]
        +-expr_list=
        | +-mx#11 := ColumnRef(type=STRING, column=$aggregate.$agg1#10)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#10]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="a"
            | | +-predicate=
            | |   +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="b"
            |   +-predicate=
            |     +-FunctionCall(ZetaSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="a")
            |     +-MatchRecognizePatternVariableRef(name="b")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
              +-MeasureGroup
                +-aggregate_list=
                  +-$agg1#10 :=
                    +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
                      +-SubqueryExpr
                        +-type=STRING
                        +-subquery_type=SCALAR
                        +-subquery=
                          +-ProjectScan
                            +-column_list=[$expr_subquery.$col1#9]
                            +-expr_list=
                            | +-$col1#9 :=
                            |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
                            |     +-ColumnRef(type=STRING, column=$match_recognize.v1#6)
                            |     +-ColumnRef(type=STRING, column=$match_recognize.v2#8)
                            +-input_scan=
                              +-ProjectScan
                                +-column_list=$match_recognize.[v1#6, v2#8]
                                +-expr_list=
                                | +-v1#6 := ColumnRef(type=STRING, column=$aggregate.$agg1#5)
                                | +-v2#8 := ColumnRef(type=STRING, column=$aggregate.$agg2#7)
                                +-input_scan=
                                  +-MatchRecognizeScan
                                    +-column_list=$aggregate.[$agg1#5, $agg2#7]
                                    +-input_scan=
                                    | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="a")
                                    +-order_by=
                                    | +-WindowOrdering
                                    |   +-order_by_item_list=
                                    |     +-OrderByItem
                                    |       +-column_ref=
                                    |         +-ColumnRef(type=INT64, column=KeyValue.Key#3)
                                    +-pattern_variable_definition_list=
                                    | +-MatchRecognizeVariableDefinition
                                    |   +-name="b"
                                    |   +-predicate=
                                    |     +-Literal(type=BOOL, value=true)
                                    +-pattern=
                                    | +-MatchRecognizePatternVariableRef(name="b")
                                    +-after_match_skip_mode=END_OF_MATCH
                                    +-measure_group_list=
                                      +-MeasureGroup
                                      | +-aggregate_list=
                                      |   +-$agg1#5 :=
                                      |     +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                                      |       +-ColumnRef(type=STRING, column=KeyValue.Value#4)
                                      +-MeasureGroup
                                        +-pattern_variable_ref=
                                        | +-MatchRecognizePatternVariableRef(name="b")
                                        +-aggregate_list=
                                          +-$agg2#7 :=
                                            +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
                                              +-ColumnRef(type=STRING, column=KeyValue.Value#4)

[UNPARSED_SQL]
SELECT
  matchrecognizescan_15.a_4 AS mx
FROM
  (
    SELECT
      KeyValue.Key AS a_1,
      KeyValue.Value AS a_2
    FROM
      KeyValue
  ) AS keyvalue_3 MATCH_RECOGNIZE(
    ORDER BY keyvalue_3.a_1
    MEASURES
      MAX((
          SELECT
            CONCAT(projectscan_13.a_11, projectscan_13.a_12) AS a_14
          FROM
            (
              SELECT
                matchrecognizescan_10.a_8 AS a_11,
                matchrecognizescan_10.a_9 AS a_12
              FROM
                (
                  SELECT
                    KeyValue.Key AS a_5,
                    KeyValue.Value AS a_6
                  FROM
                    KeyValue
                ) AS keyvalue_7 MATCH_RECOGNIZE(
                  ORDER BY keyvalue_7.a_5
                  MEASURES
                    MIN(keyvalue_7.a_6) AS a_8,
                    MIN(b.a_6) AS a_9
                  AFTER MATCH SKIP PAST LAST ROW
                  PATTERN (b)
                  DEFINE
                    b AS true
                )
                AS matchrecognizescan_10
            ) AS projectscan_13
        )) AS a_4
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN ((a  b))
    DEFINE
      a AS(LENGTH(keyvalue_3.a_2)) < 10,
      b AS(LENGTH(keyvalue_3.a_2)) >= 10
  )
  AS matchrecognizescan_15;
==

# Pattern variable references cannot be used as value tables
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES max(a) AS m
  PATTERN ( a+ )
  DEFINE
    a AS length(value) < 10
)
--
ERROR: Pattern variable a cannot be used as a value table [at 3:16]
  MEASURES max(a) AS m
               ^
==

# Unaggregated var
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES {{a|a.value}} AS m
  PATTERN ( a b* )
  DEFINE
    a AS length(value) < 10,
    b AS length(value) >= 10
)
--
ALTERNATION GROUP: a
--
ERROR: Cannot access columns through pattern variables. [at 3:12]
  MEASURES a AS m
           ^
--
ALTERNATION GROUP: a.value
--
ERROR: Cannot access columns through pattern variables. [at 3:12]
  MEASURES a.value AS m
           ^
==

# Pattern variables take precedence over struct qualifiers.
WITH t AS (SELECT STRUCT<b INT64>(1) AS a, 2 AS b)
SELECT * FROM t MATCH_RECOGNIZE (
  ORDER BY a.b, b
  MEASURES max(a.b - a.a.b) AS m1, any_value(a.a) AS m2
  PATTERN (a)
  DEFINE
    A AS true
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m1#7 AS m1 [INT64]
| +-$match_recognize.m2#9 AS m2 [STRUCT<b INT64>]
+-query=
  +-WithScan
    +-column_list=$match_recognize.[m1#7, m2#9]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[a#1, b#2]
    |       +-expr_list=
    |       | +-a#1 := Literal(type=STRUCT<b INT64>, value={b:1}, has_explicit_type=TRUE)
    |       | +-b#2 := Literal(type=INT64, value=2)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=$match_recognize.[m1#7, m2#9]
        +-input_scan=
          +-ProjectScan
            +-column_list=$match_recognize.[m1#7, m2#9]
            +-expr_list=
            | +-m1#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
            | +-m2#9 := ColumnRef(type=STRUCT<b INT64>, column=$aggregate.$agg2#8)
            +-input_scan=
              +-MatchRecognizeScan
                +-column_list=$aggregate.[$agg1#6, $agg2#8]
                +-input_scan=
                | +-ProjectScan
                |   +-column_list=[t.a#3, t.b#4, $orderby.b#5]
                |   +-expr_list=
                |   | +-b#5 :=
                |   |   +-GetStructField
                |   |     +-type=INT64
                |   |     +-expr=
                |   |     | +-ColumnRef(type=STRUCT<b INT64>, column=t.a#3)
                |   |     +-field_idx=0
                |   +-input_scan=
                |     +-WithRefScan(column_list=t.[a#3, b#4], with_query_name="t")
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |     | +-column_ref=
                |     |   +-ColumnRef(type=INT64, column=$orderby.b#5)
                |     +-OrderByItem
                |       +-column_ref=
                |         +-ColumnRef(type=INT64, column=t.b#4)
                +-pattern_variable_definition_list=
                | +-MatchRecognizeVariableDefinition
                |   +-name="A"
                |   +-predicate=
                |     +-Literal(type=BOOL, value=true)
                +-pattern=
                | +-MatchRecognizePatternVariableRef(name="A")
                +-after_match_skip_mode=END_OF_MATCH
                +-measure_group_list=
                  +-MeasureGroup
                    +-pattern_variable_ref=
                    | +-MatchRecognizePatternVariableRef(name="A")
                    +-aggregate_list=
                      +-$agg1#6 :=
                      | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                      |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
                      |     +-ColumnRef(type=INT64, column=t.b#4)
                      |     +-GetStructField
                      |       +-type=INT64
                      |       +-expr=
                      |       | +-ColumnRef(type=STRUCT<b INT64>, column=t.a#3)
                      |       +-field_idx=0
                      +-$agg2#8 :=
                        +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<b INT64>) -> STRUCT<b INT64>)
                          +-ColumnRef(type=STRUCT<b INT64>, column=t.a#3)

[UNPARSED_SQL]
WITH
  t AS (
    SELECT
      STRUCT< b INT64 > (1) AS a_1,
      2 AS a_2
  )
SELECT
  matchrecognizescan_8.a_6 AS m1,
  matchrecognizescan_8.a_7 AS m2
FROM
  (
    SELECT
      withrefscan_3.a_1 AS a_1,
      withrefscan_3.a_2 AS a_2,
      withrefscan_3.a_1.b AS a_4
    FROM
      t AS withrefscan_3
  ) AS projectscan_5 MATCH_RECOGNIZE(
    ORDER BY projectscan_5.a_4, projectscan_5.a_2
    MEASURES
      MAX((A.a_2) - (A.a_1.b)) AS a_6,
      ANY_VALUE(A.a_1) AS a_7
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (A)
    DEFINE
      A AS true
  )
  AS matchrecognizescan_8;
==

# Error on aggs mixing different ranges
# Note that `m1` has one valid combination to allow the error in the second
# alternation where the full input range appears before the pattern variable to
# also show up.
SELECT * FROM KeyValue t MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(a.key - {{|t.|b.|a.}}key) AS m1,
           min({{t.|}}key - a.key) AS m2
  PATTERN (a b)
  DEFINE
    a AS true,
    b AS true
)
--
ALTERNATION GROUPS:
    t.
    <empty>
--
ERROR: Column access ranges over all input rows in an expression that already ranges over a pattern variable a [at 3:24]
  MEASURES min(a.key - key) AS m1,
                       ^
--
ALTERNATION GROUPS:
    t.,t.
    t.,
--
ERROR: Column access ranges over all input rows in an expression that already ranges over a pattern variable a [at 3:24]
  MEASURES min(a.key - t.key) AS m1,
                       ^
--
ALTERNATION GROUPS:
    b.,t.
    b.,
--
ERROR: Column access ranges over pattern variable b in an expression that already ranges over a pattern variable a [at 3:24]
  MEASURES min(a.key - b.key) AS m1,
                       ^
--
ALTERNATION GROUP: a.,t.
--
ERROR: Column access ranges over pattern variable a in an expression that already ranges over a all input rows [at 4:24]
           min(t.key - a.key) AS m2
                       ^
--
ALTERNATION GROUP: a.,
--
ERROR: Column access ranges over pattern variable a in an expression that already ranges over a all input rows [at 4:22]
           min(key - a.key) AS m2
                     ^
==

# Coercing NULL in the DEFINE clause's predicates.
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES 1 AS m
  PATTERN (a)
  DEFINE
    A AS NULL
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#3 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#3]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#3]
        +-expr_list=
        | +-m#3 := Literal(type=INT64, value=1)
        +-input_scan=
          +-MatchRecognizeScan
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-Literal(type=BOOL, value=NULL)
            +-pattern=
            | +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH

[UNPARSED_SQL]
SELECT
  1 AS m
FROM
  (
    SELECT
      KeyValue.Key AS a_1
    FROM
      KeyValue
  ) AS keyvalue_2 MATCH_RECOGNIZE(
    ORDER BY keyvalue_2.a_1
    MEASURES
      1 AS m_3
    AFTER MATCH SKIP PAST LAST ROW
    PATTERN (A)
    DEFINE
      A AS CAST(NULL AS BOOL)
  )
  AS matchrecognizescan_4;
